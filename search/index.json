[{"content":"简介 ​\t在实验 0 中，你需要通过阅读汇编代码以及使用调试工具来拆除一个 二进制炸弹程序。本实验分为两个部分：第一部分介绍拆弹实验的基本知 识，包括 ARM 汇编语言、QEMU 模拟器、GDB 调试器的使用；第二部分 需要分析炸弹程序，推测正确的输入来使得炸弹程序能正常退出。\n文档链接：Lab0：拆炸弹 - IPADS OS Course Lab Manual\n军火展示（炸弹总览 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;stdio.h\u0026gt; #include \u0026#34;phases.h\u0026#34; #include \u0026#34;utils.h\u0026#34; int main() { char* input; printf(\u0026#34;Type in your defuse password!\\n\u0026#34;); input = read_line(); phase_0(input); phase_defused(); input = read_line(); phase_1(input); phase_defused(); input = read_line(); phase_2(input); phase_defused(); input = read_line(); phase_3(input); phase_defused(); input = read_line(); phase_4(input); phase_defused(); input = read_line(); phase_5(input); phase_defused(); printf(\u0026#34;Congrats! You have defused all phases!\\n\u0026#34;); return 0; } phase_0 1 2 3 4 5 6 7 8 9 10 11 12 0000000000400734 \u0026lt;phase_0\u0026gt;: 400734:\ta9bf7bfd stp\tx29, x30, [sp, #-16]! 400738:\t910003fd mov\tx29, sp 40073c:\t94000126 bl\t400bd4 \u0026lt;read_int\u0026gt; // 调用read_int函数读入一个整形 400740:\t90000501 adrp\tx1, 4a0000 \u0026lt;.got.plt+0x18\u0026gt; 400744:\tb9405421 ldr\tw1, [x1, #84] //获取0x4a0000+84中的值 400748:\t6b00003f cmp\tw1, w0\t//比较read_int的返回值与内存中获取的值 40074c:\t54000061 b.ne\t400758 \u0026lt;phase_0+0x24\u0026gt; //两者不相等就爆炸 400750:\ta8c17bfd ldp\tx29, x30, [sp], #16 400754:\td65f03c0 ret 400758:\t940000e7 bl\t400af4 \u0026lt;explode\u0026gt; 40075c:\t17fffffd b\t400750 \u0026lt;phase_0+0x1c\u0026gt; x0存的是我们输入的字符串，w0中存着read_int返回值，通过gdb的打印，我们可以知道答案为2022\nphase_1 1 2 3 4 5 6 7 8 9 10 11 0000000000400760 \u0026lt;phase_1\u0026gt;: 400760:\ta9bf7bfd stp\tx29, x30, [sp, #-16]! 400764:\t910003fd mov\tx29, sp 400768:\t90000501 adrp\tx1, 4a0000 \u0026lt;.got.plt+0x18\u0026gt; 40076c:\tf9402c21 ldr\tx1, [x1, #88] // 获取0x4a0000+88中的字符串 400770:\t94008504 bl\t421b80 \u0026lt;strcmp\u0026gt; // 比较输入与获取的字符串 400774:\t35000060 cbnz\tw0, 400780 \u0026lt;phase_1+0x20\u0026gt; // 不相等就爆炸 400778:\ta8c17bfd ldp\tx29, x30, [sp], #16 40077c:\td65f03c0 ret 400780:\t940000dd bl\t400af4 \u0026lt;explode\u0026gt; 400784:\t17fffffd b\t400778 \u0026lt;phase_1+0x18\u0026gt; x1中存储的是字符串的起始地址，所以在gdb打印的时候需要再次解引用\n答案：The Network as a System and as a System Component.\nphase_2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 0000000000400788 \u0026lt;phase_2\u0026gt;: 400788:\ta9bc7bfd stp\tx29, x30, [sp, #-64]! 40078c:\t910003fd mov\tx29, sp 400790:\ta90153f3 stp\tx19, x20, [sp, #16] 400794:\t910083e1 add\tx1, sp, #0x20 //数字1的地址为sp+0x20 400798:\t940000f9 bl\t400b7c \u0026lt;read_8_numbers\u0026gt; //读八个数字 40079c:\tb94023e0 ldr\tw0, [sp, #32] // 获取数字1 4007a0:\t7100041f cmp\tw0, #0x1 // 比较数字1和1 4007a4:\t54000081 b.ne\t4007b4 \u0026lt;phase_2+0x2c\u0026gt; //数字1不等于1就爆炸 4007a8:\tb94027e0 ldr\tw0, [sp, #36] // 获取数字2 4007ac:\t7100041f cmp\tw0, #0x1 // 比较数字2和1 4007b0:\t54000040 b.eq\t4007b8 \u0026lt;phase_2+0x30\u0026gt; //数字2不等于1就爆炸 4007b4:\t940000d0 bl\t400af4 \u0026lt;explode\u0026gt; 4007b8:\t910083f3 add\tx19, sp, #0x20 // x19为数字1地址 4007bc:\t9100e3f4 add\tx20, sp, #0x38 // x20为数字8地址 4007c0:\t14000004 b\t4007d0 \u0026lt;phase_2+0x48\u0026gt; /* 以下代码的c语言大致为 for(int i = 2; i \u0026lt; 8; i++){ if (num[i] != num[i-1]+num[i-2]+3) explode(); } */\t4007c4:\t91001273 add\tx19, x19, #0x4 4007c8:\teb14027f cmp\tx19, x20 4007cc:\t54000140 b.eq\t4007f4 \u0026lt;phase_2+0x6c\u0026gt; // b.none 4007d0:\tb9400260 ldr\tw0, [x19] 4007d4:\tb9400661 ldr\tw1, [x19, #4] 4007d8:\t0b010000 add\tw0, w0, w1 4007dc:\t11000c00 add\tw0, w0, #0x3 4007e0:\tb9400a61 ldr\tw1, [x19, #8] 4007e4:\t6b00003f cmp\tw1, w0 4007e8:\t54fffee0 b.eq\t4007c4 \u0026lt;phase_2+0x3c\u0026gt; // b.none 4007ec:\t940000c2 bl\t400af4 \u0026lt;explode\u0026gt; 4007f0:\t17fffff5 b\t4007c4 \u0026lt;phase_2+0x3c\u0026gt; 4007f4:\ta94153f3 ldp\tx19, x20, [sp, #16] 4007f8:\ta8c47bfd ldp\tx29, x30, [sp], #64 4007fc:\td65f03c0 ret 根据注释中的讲解，我们很容易就推出答案：1 1 5 9 17 29 49 81\nphase_3 这是一道多解题，这里只展示第一种解\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 0000000000400800 \u0026lt;phase_3\u0026gt;: 400800:\ta9be7bfd stp\tx29, x30, [sp, #-32]! 400804:\t910003fd mov\tx29, sp 400808:\t910063e3 add\tx3, sp, #0x18 // 数字2在sp+24中 40080c:\t910073e2 add\tx2, sp, #0x1c // 数字1在sp+28中 400810:\t90000321 adrp\tx1, 464000 \u0026lt;free_mem+0x40\u0026gt; 400814:\t911f6021 add\tx1, x1, #0x7d8 400818:\t9400195a bl\t406d80 \u0026lt;__isoc99_sscanf\u0026gt; // 读取两个数字 40081c:\t7100081f cmp\tw0, #0x2\t400820:\t54000161 b.ne\t40084c \u0026lt;phase_3+0x4c\u0026gt; // 如果数字个数不等于2就爆炸 400824:\tb9401fe0 ldr\tw0, [sp, #28] 400828:\t71000c1f cmp\tw0, #0x3\t40082c:\t540002c0 b.eq\t400884 \u0026lt;phase_3+0x84\u0026gt; // 数字1为3则跳转到0x400884处 400830:\t7100181f cmp\tw0, #0x6 400834:\t54000100 b.eq\t400854 \u0026lt;phase_3+0x54\u0026gt; // b.none 400838:\t7100081f cmp\tw0, #0x2 40083c:\t54000320 b.eq\t4008a0 \u0026lt;phase_3+0xa0\u0026gt; // b.none 400840:\t940000ad bl\t400af4 \u0026lt;explode\u0026gt; 400844:\ta8c27bfd ldp\tx29, x30, [sp], #32 400848:\td65f03c0 ret 40084c:\t940000aa bl\t400af4 \u0026lt;explode\u0026gt; 400850:\t17fffff5 b\t400824 \u0026lt;phase_3+0x24\u0026gt; 400854:\tb9401be2 ldr\tw2, [sp, #24] 400858:\t528ccce0 mov\tw0, #0x6667 // #26215 40085c:\t72acccc0 movk\tw0, #0x6666, lsl #16 400860:\t9b207c40 smull\tx0, w2, w0 400864:\t9362fc00 asr\tx0, x0, #34 400868:\t4b827c00 sub\tw0, w0, w2, asr #31 40086c:\t0b000801 add\tw1, w0, w0, lsl #2 400870:\t4b010441 sub\tw1, w2, w1, lsl #1 400874:\t0b000020 add\tw0, w1, w0 400878:\t7100181f cmp\tw0, #0x6 40087c:\t54fffe40 b.eq\t400844 \u0026lt;phase_3+0x44\u0026gt; // b.none 400880:\t9400009d bl\t400af4 \u0026lt;explode\u0026gt; 400884:\tb9401be0 ldr\tw0, [sp, #24] //读取数字2 400888:\t4a800c00 eor\tw0, w0, w0, asr #3 40088c:\t12000800 and\tw0, w0, #0x7 // 设数字2为x2，此时w0 = (x2 \u0026gt;\u0026gt; 3) \u0026amp; 7 400890:\tb9401fe1 ldr\tw1, [sp, #28] //读取数字1 400894:\t6b01001f cmp\tw0, w1 400898:\t54fffd60 b.eq\t400844 \u0026lt;phase_3+0x44\u0026gt; // 数字1等于w0则返回 40089c:\t94000096 bl\t400af4 \u0026lt;explode\u0026gt; 4008a0:\tb9401be0 ldr\tw0, [sp, #24] 4008a4:\tb9401fe1 ldr\tw1, [sp, #28] 4008a8:\t12000802 and\tw2, w0, #0x7 4008ac:\t6b01005f cmp\tw2, w1 4008b0:\t54fffca0 b.eq\t400844 \u0026lt;phase_3+0x44\u0026gt; // b.none 4008b4:\td3431400 ubfx\tx0, x0, #3, #3 4008b8:\t6b00003f cmp\tw1, w0 4008bc:\t54fffc40 b.eq\t400844 \u0026lt;phase_3+0x44\u0026gt; // b.none 4008c0:\t9400008d bl\t400af4 \u0026lt;explode\u0026gt; 4008c4:\t17ffffdf b\t400840 \u0026lt;phase_3+0x40\u0026gt; 输入两个数x1,x2，若 x1 为 3，则 x1 == (x2 \u0026raquo; 3) \u0026amp; 7\n答案：3 3 or 3 24 \u0026hellip;（符合上述规则都对）\nphase_4 1 2 3 4 5 400300:\t90000510 adrp\tx16, 4a0000 \u0026lt;.got.plt+0x18\u0026gt; 400304:\tf9401a11 ldr\tx17, [x16, #48]\t// 将0x4a0030所存的函数地址放到x17中 400308:\t9100c210 add\tx16, x16, #0x30 40030c:\td61f0220 br\tx17 // 跳转到该函数执行 // 通过gdb打印的地址，我们可以查询到函数的名字是 strlen 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 00000000004009e4 \u0026lt;phase_4\u0026gt;: 4009e4:\ta9be7bfd stp\tx29, x30, [sp, #-32]! 4009e8:\t910003fd mov\tx29, sp 4009ec:\ta90153f3 stp\tx19, x20, [sp, #16] 4009f0:\taa0003f3 mov\tx19, x0 // 将输入复制一份到x19 4009f4:\t97fffe43 bl\t400300 \u0026lt;.plt+0x60\u0026gt; // 跳转到外部链接（400300代码在上面） 4009f8:\taa0003f4 mov\tx20, x0 // 将输入复制一份到x20 4009fc:\t7100281f cmp\tw0, #0xa 400a00:\t540001ec b.gt\t400a3c \u0026lt;phase_4+0x58\u0026gt; // 如果返回值大于10就爆炸 400a04:\t2a1403e1 mov\tw1, w20 400a08:\taa1303e0 mov\tx0, x19 400a0c:\t97ffffaf bl\t4008c8 \u0026lt;encrypt_method1\u0026gt; // 加密函数1 400a10:\t2a1403e1 mov\tw1, w20 400a14:\taa1303e0 mov\tx0, x19 400a18:\t97ffffd3 bl\t400964 \u0026lt;encrypt_method2\u0026gt; // 加密函数2 400a1c:\t90000500 adrp\tx0, 4a0000 \u0026lt;.got.plt+0x18\u0026gt; 400a20:\tf9403401 ldr\tx1, [x0, #104] // 获取0x4a0000+104处的值，是一个字符串 400a24:\taa1303e0 mov\tx0, x19 400a28:\t94008456 bl\t421b80 \u0026lt;strcmp\u0026gt; // 调用strcmp函数比较 // 如果加密后的字符串与获取的字符串不等就爆炸 400a2c:\t350000c0 cbnz\tw0, 400a44 \u0026lt;phase_4+0x60\u0026gt; 400a30:\ta94153f3 ldp\tx19, x20, [sp, #16] 400a34:\ta8c27bfd ldp\tx29, x30, [sp], #32 400a38:\td65f03c0 ret 400a3c:\t9400002e bl\t400af4 \u0026lt;explode\u0026gt; 400a40:\t17fffff1 b\t400a04 \u0026lt;phase_4+0x20\u0026gt; 400a44:\t9400002c bl\t400af4 \u0026lt;explode\u0026gt; 400a48:\t17fffffa b\t400a30 \u0026lt;phase_4+0x4c\u0026gt; 这道题有点难，但我们可以很快知道需要输入一个长度不大于10的字符串，且我们也可以很快知道最终要比较的字符串为isggstsvkt\n接下来是要知道两个加密函数做了些什么，然而通过看代码，我们其实很难看懂是怎么加密的，但是我们可以通过不断地输入来获取算法结果，最终得到算法的加密方式。\n通过输入0123456789我们可以得到经过加密函数1之后的结果为0246813579，很显然这是将位置做了一下调换。然而这个输入在加密函数2中直接就爆炸了\n结合最终字符串以及输入0123456789的结果，我们可以猜测函数2是一个字母表的加密算法，故而我们尝试输入abcdefghij，得到经过加密函数2的结果为qetuowryip，之后我们可以很容易的得到abcdefghij在加密表中对应qwertyuiop，将26个字母都输入了一遍之后，我们就可以知道应该输入的字符串为helloworle\nphase_5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 0000000000400a4c \u0026lt;func_5\u0026gt;: // 通过分析这个函数，我们可以知道参数2应该为一个二叉树的根地址 400a4c:\tb4000361 cbz\tx1, 400ab8 \u0026lt;func_5+0x6c\u0026gt; // 如果该节点为空就返回0 400a50:\ta9be7bfd stp\tx29, x30, [sp, #-32]! 400a54:\t910003fd mov\tx29, sp 400a58:\ta90153f3 stp\tx19, x20, [sp, #16] 400a5c:\t2a0003f4 mov\tw20, w0 400a60:\taa0103f3 mov\tx19, x1 400a64:\tb9400020 ldr\tw0, [x1] 400a68:\t6b14001f cmp\tw0, w20 400a6c:\t54000160 b.eq\t400a98 \u0026lt;func_5+0x4c\u0026gt; // b.none 400a70:\tb9400260 ldr\tw0, [x19] 400a74:\t6b14001f cmp\tw0, w20 400a78:\t5400014d b.le\t400aa0 \u0026lt;func_5+0x54\u0026gt; 400a7c:\tf9400661 ldr\tx1, [x19, #8] 400a80:\t2a1403e0 mov\tw0, w20 400a84:\t97fffff2 bl\t400a4c \u0026lt;func_5\u0026gt; 400a88:\t531f7800 lsl\tw0, w0, #1 400a8c:\ta94153f3 ldp\tx19, x20, [sp, #16] 400a90:\ta8c27bfd ldp\tx29, x30, [sp], #32 400a94:\td65f03c0 ret 400a98:\t94000017 bl\t400af4 \u0026lt;explode\u0026gt; 400a9c:\t17fffff5 b\t400a70 \u0026lt;func_5+0x24\u0026gt; 400aa0:\tf9400a61 ldr\tx1, [x19, #16] 400aa4:\t2a1403e0 mov\tw0, w20 400aa8:\t97ffffe9 bl\t400a4c \u0026lt;func_5\u0026gt; 400aac:\t531f7800 lsl\tw0, w0, #1 400ab0:\t11000400 add\tw0, w0, #0x1 400ab4:\t17fffff6 b\t400a8c \u0026lt;func_5+0x40\u0026gt; 400ab8:\t52800000 mov\tw0, #0x0 // #0 400abc:\td65f03c0 ret 1 2 3 4 5 6 7 8 9 10 11 12 13 14 0000000000400ac0 \u0026lt;phase_5\u0026gt;: 400ac0:\ta9bf7bfd stp\tx29, x30, [sp, #-16]! 400ac4:\t910003fd mov\tx29, sp 400ac8:\t94000043 bl\t400bd4 \u0026lt;read_int\u0026gt; // 读入一个整数 400acc:\t90000501 adrp\tx1, 4a0000 \u0026lt;.got.plt+0x18\u0026gt; 400ad0:\t91016021 add\tx1, x1, #0x58 400ad4:\t91006021 add\tx1, x1, #0x18 400ad8:\t97ffffdd bl\t400a4c \u0026lt;func_5\u0026gt; // 调用一个函数，参数2为一个地址 400adc:\t71000c1f cmp\tw0, #0x3 400ae0:\t54000061 b.ne\t400aec \u0026lt;phase_5+0x2c\u0026gt; //返回值不等于3就爆炸 400ae4:\ta8c17bfd ldp\tx29, x30, [sp], #16 400ae8:\td65f03c0 ret 400aec:\t94000002 bl\t400af4 \u0026lt;explode\u0026gt; 400af0:\t17fffffd b\t400ae4 \u0026lt;phase_5+0x24\u0026gt; 这道题也很难，但我们可以一力破万法，既然我们已经知道需要遍历一个二叉树，那我们一个个打印，可以知道二叉树的结构如下：\n如果你懒得看func_5的逻辑了，那么你可以跟我一样一个一个试，将所有二叉树插入节点的位置都试一遍，比如：0, 4, 21, 38, 50, 56, 89, 92，当我们试到89时就得到答案了。\n","date":"2024-11-17T16:07:58+08:00","permalink":"http://localhost:1313/blogs/chcore_lab0-%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0/","title":"ChCore_lab0 做题笔记"},{"content":"WSL 连接 Vscode 打开 vscode 点击左下角的蓝色标 选择连接到WSL即可连接到默认的WSL子系统，如果你有多个子系统，可以选择使用发行版连接到WSL，然后选择你想要连接的子系统 进入子系统之后你就可以像在本地一样使用 vscode 来操作子系统啦，你可以使用快捷键 ctrl+`快速调出终端，然后就可以进行一些命令行操作啦\n安装vscode插件 由于使用vscode连接wsl的原理是在wsl里面开启一个vscode server，所以本机的插件是不会与wsl里面的插件共享的，你需要在插件页面安装对应的插件。\n推荐两个好用的 vscode 插件\nFavorites Manager：简单方便地文件夹收藏夹，将你常用文件夹添加到收藏夹，之后就可以通过它快速打开 Open Folder Context Menus for VS Code：可以让你快速地打开文件夹中的子文件夹，配合Favorites Manager可以高效找寻并打开想要的文件夹路径 ​\t由于vscode扩展的服务器是在国外，所以安装插件会出现加载缓慢或者加载不出来的情况，为了良好的体验，建议使用魔法来加速\n​\t不单止vscode，目前jetbrains全家桶也支持连接wsl来进行项目开发，不过笔者不常用jetbrains系的ide，所以没有实际体验过，感兴趣的可以自行去体验一下\n","date":"2024-10-30T23:47:42+08:00","image":"http://localhost:1313/blogs/03-%E5%9C%A8vscode%E4%B8%AD%E4%BD%BF%E7%94%A8wsl%E8%BF%9B%E8%A1%8C%E5%BC%80%E5%8F%91/OIP-C_x16_drawing_hu14351242286450249137.jpg","permalink":"http://localhost:1313/blogs/03-%E5%9C%A8vscode%E4%B8%AD%E4%BD%BF%E7%94%A8wsl%E8%BF%9B%E8%A1%8C%E5%BC%80%E5%8F%91/","title":"03 在VSCode中使用WSL进行开发"},{"content":"安装 WSL Toolbox 使用 Microsoft Store 搜索 \u0026ldquo;WSL Toolbox\u0026rdquo;，点击安装即可。 也可以通过此链接安装：WSL Toolbox\n配置默认启动用户 (仅Ubuntu，其它发行版自行搜索) 不管使用 WSL 命令还是在 WSL Toolbox（以下简称 WT）中进入子系统，默认是使用root模式访问的，接下来我们要将默认访问用户改成安装系统时创建的那个。如果你享受root模式的裸奔快感，这一步可以跳过。\n先检查 wsl.conf 文件是否存在\n1 cat /etc/wsl.conf 如果文件不存在则创建一个\n1 touch /etc/wsl.conf 将以下内容写入该文件\n1 2 3 4 [boot] systemd=true #启用systemd命令，无脑开就行，能够解决一些兼容性问题 [user] default=YourName #这里替换成你的用户名 由于只能在子系统内部更改该文件，所以学会使用vim是必要的： Linux vi/vim | 菜鸟教程 (runoob.com)\n重启子系统即可生效 （推荐使用WT操作）\n更改子系统路径 子系统默认安装在C盘，为了不过分占用C盘空间，修改子系统路径是很必要的\n使用 WT 导出子系统\n点击Export之后保存到你想要存放子系统的路径（甚至可以存放在移动硬盘中）\n使用 WT 导入你的子系统\n选择刚刚导出的子系统文件，只修改系统名称即可\n将原来的子系统 Delete 掉就好了\n导出的子系统文件千万不要删除，以备后续可以通过 import 方便地增加子系统或者重装子系统\n如果你将wsl系统装在了外置存储设备，请不要在存储设备离开时打开WT，否则会导致WT崩溃，需要自行前往修复\n具体操作： 设置 \u0026raquo; 应用 \u0026raquo; 安装的应用 \u0026raquo; 找到WT选择高级选项 \u0026raquo; 修复 or 重置\n参考链接 WSL入门到入土 - 知乎 (zhihu.com) WSL Toolbox Linux vi/vim | 菜鸟教程 (runoob.com) ","date":"2024-10-02T23:45:47+08:00","image":"http://localhost:1313/blogs/02-%E4%BD%BF%E7%94%A8wsl-toolbox%E7%AE%A1%E7%90%86%E4%BD%A0%E7%9A%84linux%E5%AD%90%E7%B3%BB%E7%BB%9F/OIP-C_x16_drawing_hu14351242286450249137.jpg","permalink":"http://localhost:1313/blogs/02-%E4%BD%BF%E7%94%A8wsl-toolbox%E7%AE%A1%E7%90%86%E4%BD%A0%E7%9A%84linux%E5%AD%90%E7%B3%BB%E7%BB%9F/","title":"02 使用WSL ToolBox管理你的Linux子系统"},{"content":" ​\t随着我们学习的编程语言越来越多，使用的各种各样的工具也越来越多，我们的电脑上就需要配置越来越多的环境，且不论环境之间是否具有冲突，单从复杂的系统环境来看，都会让电脑变的臃肿，最终就会出现牵一发而动全身的情况（All in boom）。\n​\t然而，目前win平台对于此并没有过多的方案选择，基本只有docker、Windows沙盒、传统VM以及 WSL 三个选项来管理你的系统环境，让系统变得更加清爽。\n​\tWindows沙盒只能在专业版中使用，鉴于大部分人都没有专业版，故并不推荐； 传统VM由于运行在应用层，在进行资源调度以及数据共享时极不方便，故不推荐；docker，由于docker并没有win的原生版本，即使是windows版本也是基于wsl的，于是乎你就在装了一个wsl的前提下，又安装了个docker，在神级插件Dev-Container辅助下，确实很不错，由于笔者没有尝试过，所以不做评价。\n​\tWSL也是一种虚拟机，由于win的原生支持，其不仅能够与win进行极其方便的数据共享，还能够方便的与宇宙第一IDE VScode 进行一触即连，优雅方便地开始你的代码开发，最重要的是，其能够完美地调用所有的计算资源而不需要手动调整，实在是管理系统环境的不二之选。\n​\t2024.11.12 笔者的笔记本坏了，需要重装系统，尽管重要数据能够通过硬盘、网盘来备份，但是一些系统环境要重新配置还是很费时间的。由于笔者已经投入了wsl怀抱，这时候只需要将所有的子系统导出，然后重要数据都放在同步盘里，就能够非常方便地重装系统然后恢复原来的环境了。\n启用基于Linux的子系统功能 在 Win10 or Win11 中，使用任务栏的搜索功能，搜索“启用或关闭windows功能”\n单击进入下图窗口，启用 “适用于Linux的Windows子系统功能” 和 \u0026ldquo;虚拟机平台\u0026rdquo;\n安装 WSL 子系统 使用 cmd，输入以下命令更新 WSL\n1 WSL --update 启用 WSL2 —— 目前默认使用 WSL2，但建议手动启用一下更为保险，WSL2 的功能比 1 更完善也更加稳定\n1 WSL --set-default-version 2 查看可用的WSL系统版本，并安装ubuntu系统 —— 这里安装的是22.04版本，没特殊需求使用22.04版本就够了\n1 2 WSL -l -o WSL --install Ubuntu-22.04 --web-download 这里请务必加上 --web-download ，否则他会从MS Store下载，亲测奇慢无比\n接下来只需跟着引导创建用户然后，设置密码即可，之后你可以在CMD或者Power Shell输入WSL来进入子系统\n意外情况 不出意外的话，这时候可能就出意外了\n意外一\n1 WSL -l -o 如果没有反应，这一般是那堵无形的墙堵住了你的去路。\n解决方法: 尝试换一个网绕过去，或者装个梯子爬过去\nps：经笔者尝试，目前国内是可以直接访问安装的，如果不行，配置一下DNS就好了\n​\t推荐：首选119.29.29.29 备用8.8.8.8\n意外二\n1 WSL --install Ubuntu-22.04 --web-download 安装系统失败，首先尝试根据官方文档中的操作一步一步来：旧版 WSL 的手动安装步骤 | Microsoft Learn\n如果仍然安装系统失败，你可以尝试使用windows更新修复问题，然后重试上述步骤。\n还有可能是因为bios未启用cpu虚拟化。 —— 然而 笔者在使用VM时显示不支持cpu虚拟化，但却能够使用WSL\n此时依然不行的话，要么就是系统不支持，要么就是硬件不支持，可以尝试重装系统或者更换电脑解决\n参考链接： WSL入门到入土 - 知乎 (zhihu.com) 旧版 WSL 的手动安装步骤 | Microsoft Learn ","date":"2024-10-01T23:46:05+08:00","image":"http://localhost:1313/blogs/01-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8wsl%E5%AE%89%E8%A3%85linux%E7%B3%BB%E7%BB%9F/OIP-C_x16_drawing_hu14351242286450249137.jpg","permalink":"http://localhost:1313/blogs/01-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8wsl%E5%AE%89%E8%A3%85linux%E7%B3%BB%E7%BB%9F/","title":"01 如何使用WSL安装Linux系统"}]