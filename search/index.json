[{"content":"简介 文档链接：Lab2: 内存管理 - IPADS OS Course Lab Manual\n本实验主要目的在于让同学们熟悉内核启动过程中对内存的初始化和内核启动后对物理内存和页表的管理，包括三个部分。\n物理内存管理: 理解并完成伙伴系统以及SLAB系统 虚拟页表管理: 深入理解页表分配机制以及页表项权限机制，并完成页表分配函数。 缺页异常处理: 理解aarch64架构下的异常处理机制，并按照页表项的配置完成按需分配以及写时拷贝的缺页管理设置。 ！本次实验由于时间紧任务重，只完成代码部分\n代码导读（list_head, 页表原理并不在此列，自行了解） 从main函数讲起，在初始化完cpu信息之后，就开始初始化页表（mm_init）\nmm_init 函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void mm_init(void *physmem_info) { int physmem_map_idx; /* Step-1: 解析physmem_info以获取physmem的每个连续范围 */ physmem_map_num = 0; //表示总共有多少个内存池 parse_mem_map(physmem_info); // 解析完之后会修改上述的physmem_map_num值 /* Step-2: init the buddy allocators for each continuous range of the * physmem. */ for (physmem_map_idx = 0; physmem_map_idx \u0026lt; physmem_map_num; ++physmem_map_idx) init_buddy_for_one_physmem_map(physmem_map_idx); // 初始化内存池 /* Step-3: init the slab allocator. */ init_slab(); } init_buddy_for_one_physmem_map函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 static void init_buddy_for_one_physmem_map(int physmem_map_idx) { paddr_t free_mem_start = 0; /* ...省略变量初始化操作 */ paddr_t free_page_start = 0; free_mem_start = physmem_map[physmem_map_idx][0]; // 该内存池的起始地址 free_mem_end = physmem_map[physmem_map_idx][1]; // 该内存池的结束位置 // 计算该内存池可以分配的页表数 npages = (free_mem_end - free_mem_start) // 内存大小 / (PAGE_SIZE + sizeof(struct page)); // 要加上页表元数据的大小 free_page_start = ROUND_UP( // 可分配的页表内存起始地址（ROUND_UP表示按页向上对齐） free_mem_start + npages * sizeof(struct page), PAGE_SIZE); /* 对齐后重新计算 npages。*/ npages1 = (free_mem_end - free_page_start) / PAGE_SIZE; npages = npages \u0026lt; npages1 ? npages : npages1; // 将起始地址初始化为第一个页表元数据 page_meta_start = (struct page *)phys_to_virt(free_mem_start); /* 根据该空闲内存区域初始化伙伴分配器。 */ init_buddy(\u0026amp;global_mem[physmem_map_idx], page_meta_start, phys_to_virt(free_page_start), npages); } 页表相关结构体 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 struct page { struct list_head node; int allocated; // 对应的物理页面现在是否空闲 int order; // 该页面所属的内存块的阶数，判断内存页大小的唯一根据 void *slab; // 用于 ChCore slab 分配器 struct phys_mem_pool *pool; // 所属的内存池 }; struct free_list { struct list_head free_list; unsigned long nr_free; }; struct phys_mem_pool { // 该结构体不归伙伴系统管辖 vaddr_t pool_start_addr; // 该物理内存池的起始虚拟地址（供内核使用） unsigned long pool_mem_size; // 内存池管理的内存大小 // 该池的元数据区域的起始虚拟地址（供内核使用） struct page *page_metadata; // 第一个页的地址 struct lock buddy_lock; // 内存池的锁 /* 内存块的空闲列表，根据order存储 */ struct free_list free_lists[BUDDY_MAX_ORDER]; /* * This field is only used in ChCore unit test. * The number of (4k) physical pages in this physical memory pool. * 不重要 */ unsigned long pool_phys_page_num; }; 初始化伙伴系统 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 void init_buddy(struct phys_mem_pool *pool, struct page *start_page, vaddr_t start_addr, unsigned long page_num) { int order; int page_idx; struct page *page; BUG_ON(lock_init(\u0026amp;pool-\u0026gt;buddy_lock) != 0); /* 初始化物理内存池的元数据 */ pool-\u0026gt;pool_start_addr = start_addr; pool-\u0026gt;page_metadata = start_page; pool-\u0026gt;pool_mem_size = page_num * BUDDY_PAGE_SIZE; /* This field is for unit test only. （不重要）*/ pool-\u0026gt;pool_phys_page_num = page_num; /* 初始化内存池中的链表 */ for (order = 0; order \u0026lt; BUDDY_MAX_ORDER; ++order) { pool-\u0026gt;free_lists[order].nr_free = 0; init_list_head(\u0026amp;(pool-\u0026gt;free_lists[order].free_list)); } /* 初始化所有的页表元数据为 0 */ memset((char *)start_page, 0, page_num * sizeof(struct page)); /* 初始化所有的页表元数据为 已分配. */ for (page_idx = 0; page_idx \u0026lt; page_num; ++page_idx) { page = start_page + page_idx; page-\u0026gt;allocated = 1; page-\u0026gt;order = 0; page-\u0026gt;pool = pool; } /* 通过buddy_free_pages函数来将页表放入内存池的链表内 */ for (page_idx = 0; page_idx \u0026lt; page_num; ++page_idx) { page = start_page + page_idx; buddy_free_pages(pool, page); } } 获取伙伴块以及地址转换函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 __maybe_unused static struct page *get_buddy_chunk(struct phys_mem_pool *pool, struct page *chunk) { vaddr_t chunk_addr; vaddr_t buddy_chunk_addr; int order; /* Get the address of the chunk. */ chunk_addr = (vaddr_t)page_to_virt(chunk); order = chunk-\u0026gt;order; /* * Calculate the address of the buddy chunk according to the address * relationship between buddies. */ // 根据order和chunk在特定位取反来获取伙伴块地址 buddy_chunk_addr = chunk_addr ^ (1UL \u0026lt;\u0026lt; (order + BUDDY_PAGE_SIZE_ORDER)); /* Check whether the buddy_chunk_addr belongs to pool. */ // 判断该伙伴块是否在这个内存池的管辖范围 if ((buddy_chunk_addr \u0026lt; pool-\u0026gt;pool_start_addr) || ((buddy_chunk_addr + (1 \u0026lt;\u0026lt; order) * BUDDY_PAGE_SIZE) \u0026gt; (pool-\u0026gt;pool_start_addr + pool-\u0026gt;pool_mem_size))) { return NULL; } return virt_to_page((void *)buddy_chunk_addr); } void *page_to_virt(struct page *page) { vaddr_t addr; struct phys_mem_pool *pool = page-\u0026gt;pool; BUG_ON(pool == NULL); /* page_idx * BUDDY_PAGE_SIZE + start_addr */ addr = (page - pool-\u0026gt;page_metadata) * BUDDY_PAGE_SIZE + pool-\u0026gt;pool_start_addr; return (void *)addr; } struct page *virt_to_page(void *ptr) { struct page *page; struct phys_mem_pool *pool = NULL; vaddr_t addr = (vaddr_t)ptr; int i; /* 找到对应的物理内存池 */ for (i = 0; i \u0026lt; physmem_map_num; ++i) { if (addr \u0026gt;= global_mem[i].pool_start_addr \u0026amp;\u0026amp; addr \u0026lt; global_mem[i].pool_start_addr + global_mem[i].pool_mem_size) { pool = \u0026amp;global_mem[i]; break; } } if (pool == NULL) { kdebug(\u0026#34;invalid pool in %s\u0026#34;, __func__); return NULL; } // 根据输入虚拟的地址计算出对应的页表地址 page = pool-\u0026gt;page_metadata + (((vaddr_t)addr - pool-\u0026gt;pool_start_addr) / BUDDY_PAGE_SIZE); return page; } 练习题1 完成 kernel/mm/buddy.c 中的 split_chunk、merge_chunk、buddy_get_pages、 和 buddy_free_pages 函数中的 LAB 2 TODO 1 部分，其中 buddy_get_pages 用于分配指定阶大小的连续物理页，buddy_free_pages 用于释放已分配的连续物理页。\n根据init_buddy中对buddy_free_pages的使用，我们知道这个函数主要是将page-\u0026gt;allocated设置回0，再结合伙伴系统的知识，我们知道在释放完内存之后还要尽可能地合并伙伴，即调用merge_chunk函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 void buddy_free_pages(struct phys_mem_pool *pool, struct page *page) { int order; struct list_head *free_list; lock(\u0026amp;pool-\u0026gt;buddy_lock); // 为了保证多线程数据安全，操作内存池时要获取锁 /* LAB 2 TODO 1 BEGIN */ /* * Hint: Merge the chunk with its buddy and put it into * a suitable free list. */ /* BLANK BEGIN */ page-\u0026gt;allocated = 0; // 先设置为未分配 page = merge_chunk(pool, page); // 合并伙伴块 order = page-\u0026gt;order; // 获取合并之后的伙伴 order 值 // 由于merge之后page所指向不一定是原来的page，为了保险，再次设置为未分配 page-\u0026gt;allocated = 0; // 将页表放入内存池中进行管理 free_list = \u0026amp;(pool-\u0026gt;free_lists[order].free_list); list_add(\u0026amp;(page-\u0026gt;node), free_list); pool-\u0026gt;free_lists[order].nr_free += 1; /* BLANK END */ /* LAB 2 TODO 1 END */ unlock(\u0026amp;pool-\u0026gt;buddy_lock); } __maybe_unused static struct page * merge_chunk(struct phys_mem_pool *__maybe_unused pool, struct page *__maybe_unused chunk) { /* LAB 2 TODO 1 BEGIN */ /* * Hint: Recursively merge current chunk with its buddy * if possible. 递归合并至不能合并 */ /* BLANK BEGIN */ if (chunk-\u0026gt;order == BUDDY_MAX_ORDER - 1) // 如果当前块已经是最大块，直接返回本身 return chunk; struct page *buddy_chunk = get_buddy_chunk(pool, chunk); // 获取伙伴块 // 如果找不到伙伴、伙伴被分配、伙伴的阶数与自己不等（该页不完整）就停止合并 if (buddy_chunk == NULL) return chunk; if (buddy_chunk-\u0026gt;allocated == 1) return chunk; if (buddy_chunk-\u0026gt;order != chunk-\u0026gt;order) return chunk; // 如果能够合并，就将伙伴从内存池中取出 list_del(\u0026amp;(buddy_chunk-\u0026gt;node)); pool-\u0026gt;free_lists[buddy_chunk-\u0026gt;order].nr_free -= 1; // 将两个伙伴合并 buddy_chunk-\u0026gt;order += 1; chunk-\u0026gt;order += 1; if (buddy_chunk \u0026lt; chunk) // 确保低地址在前 chunk = buddy_chunk; return merge_chunk(pool, chunk); // 递归合并并返回合并后的块 /* BLANK END */ /* LAB 2 TODO 1 END */ } 参照merge_chunk和buddy_free_pages，实现split_chunk和buddy_get_pages\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 struct page *buddy_get_pages(struct phys_mem_pool *pool, int order) { int cur_order; struct list_head *free_list; struct page *page = NULL; if (unlikely(order \u0026gt;= BUDDY_MAX_ORDER)) { kwarn(\u0026#34;ChCore does not support allocating such too large \u0026#34; \u0026#34;contious physical memory\\n\u0026#34;); return NULL; } lock(\u0026amp;pool-\u0026gt;buddy_lock); /* LAB 2 TODO 1 BEGIN */ /* * Hint: Find a chunk that satisfies the order requirement * in the free lists, then split it if necessary. */ /* BLANK BEGIN */ cur_order = order; // 找到符合条件的空闲块 while (pool-\u0026gt;free_lists[cur_order].nr_free \u0026lt;= 0 \u0026amp;\u0026amp; cur_order \u0026lt; BUDDY_MAX_ORDER) cur_order++; if (cur_order \u0026gt;= BUDDY_MAX_ORDER) // 如果没找到则返回 goto out; // 取出一个空闲块 free_list = \u0026amp;(pool-\u0026gt;free_lists[cur_order].free_list); // 这里的链表头是一个不存东西的 page = list_entry(free_list-\u0026gt;next, struct page, node); pool-\u0026gt;free_lists[page-\u0026gt;order].nr_free -= 1; list_del(\u0026amp;(page-\u0026gt;node)); // 将空闲块分割为想要的块 page = split_chunk(pool, order, page); page-\u0026gt;allocated = 1; /* BLANK END */ /* LAB 2 TODO 1 END */ out: __maybe_unused unlock(\u0026amp;pool-\u0026gt;buddy_lock); return page; } __maybe_unused static struct page * split_chunk(struct phys_mem_pool *__maybe_unused pool, int __maybe_unused order, struct page *__maybe_unused chunk) { /* LAB 2 TODO 1 BEGIN */ /* * Hint: Recursively put the buddy of current chunk into * a suitable free list. */ /* BLANK BEGIN */ if (chunk-\u0026gt;order == order) // 如果当前块阶数等于想要的阶数 return chunk; chunk-\u0026gt;order -= 1; // 缩小当前快为原来一半 struct page *buddy = get_buddy_chunk(pool, chunk); // 获取伙伴块 // 将伙伴块设置为未分配，并且将伙伴块放入内存池中 buddy-\u0026gt;allocated = 0; buddy-\u0026gt;order = chunk-\u0026gt;order; pool-\u0026gt;free_lists[buddy-\u0026gt;order].nr_free += 1; list_add(\u0026amp;(buddy-\u0026gt;node), \u0026amp;(pool-\u0026gt;free_lists[buddy-\u0026gt;order].free_list)); return split_chunk(pool, order, chunk); /* BLANK END */ /* LAB 2 TODO 1 END */ } 练习题2 完成 kernel/mm/slab.c 中的 choose_new_current_slab、alloc_in_slab_impl 和 free_in_slab 函数中的 LAB 2 TODO 2 部分，其中 alloc_in_slab_impl 用于在 slab 分配器中分配指定阶大小的内存，而 free_in_slab 则用于释放上述已分配的内存。\n前置代码：\n在初始化完伙伴分配器之后，开始初始化slab分配器\n1 2 3 4 5 6 7 8 9 10 11 12 void init_slab(void) { int order; /* slab obj size: 32, 64, 128, 256, 512, 1024, 2048 （单位：B）*/ // 根据上述单位大小，我们可以知道slab的阶数为 5 到 11 for (order = SLAB_MIN_ORDER; order \u0026lt;= SLAB_MAX_ORDER; order++) { lock_init(\u0026amp;slabs_locks[order]); // 初始化锁 slab_pool[order].current_slab = NULL; // 初始化池 init_list_head(\u0026amp;(slab_pool[order].partial_slab_list)); // 初始化链表 } kdebug(\u0026#34;mm: finish initing slab allocators\\n\u0026#34;); } slab_pool的定义\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 struct slab_pointer slab_pool[SLAB_MAX_ORDER + 1]; struct slab_pointer { struct slab_header *current_slab; struct list_head partial_slab_list; // 串slab_header的链表头 }; /* slab_header 位于每个 slab 的开头 (内容存储在第一个 slot). */ struct slab_header { /* 空闲slot列表，可以转换为struct slab_slot_list. */ void *free_list_head; // 用来将空闲位置串起来 /* Partial slab list. */ struct list_head node; // 每个slab都要和其它slab串起来 int order; // 阶数 unsigned short total_free_cnt; /* MAX: 65536 */ unsigned short current_free_cnt; // 当前空闲数 }; /* 一个slab中的每个空闲slot都被视为slab_slot_list。. */ struct slab_slot_list { void *next_free; }; static struct slab_header *init_slab_cache(int order, int size) { void *addr; struct slab_slot_list *slot; struct slab_header *slab; unsigned long cnt, obj_size; int i; addr = alloc_slab_memory(size); // 分配一个内存来当作slab if (unlikely(addr == NULL)) /* Fail: no available memory. */ return NULL; slab = (struct slab_header *)addr; obj_size = order_to_size(order); // 每个槽的大小 /* The first slot is used as metadata (struct slab_header). */ BUG_ON(obj_size == 0); cnt = size / obj_size - 1; // 总共可用的槽数量（第一个槽存元数据） // 第二个槽的地址 slot = (struct slab_slot_list *)((vaddr_t)addr + obj_size); // 将第二个槽放入链表头，根据上下文，可以知道这个链表头是可用的，而不像伙伴系统的链表头 slab-\u0026gt;free_list_head = (void *)slot; slab-\u0026gt;order = order; slab-\u0026gt;total_free_cnt = cnt; slab-\u0026gt;current_free_cnt = cnt; /* 循环将所有的空闲槽串起来 \u0026amp; The last slot has no next one. */ for (i = 0; i \u0026lt; cnt - 1; ++i) { slot-\u0026gt;next_free = (void *)((unsigned long)slot + obj_size); slot = (struct slab_slot_list *)((unsigned long)slot + obj_size); } slot-\u0026gt;next_free = NULL; return slab; } 题解：\nchoose_new_current_slab函数，从slab_list中将下一个slab放到current_slab上\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 static void choose_new_current_slab(struct slab_pointer *__maybe_unused pool) { /* LAB 2 TODO 2 BEGIN */ /* Hint: Choose a partial slab to be a new current slab. */ /* BLANK BEGIN */ struct list_head *slab_list; slab_list = \u0026amp;(pool-\u0026gt;partial_slab_list); // 获取slab list链表头 if (list_empty(slab_list)) { // 如果为空则将current_slab设置为空 pool-\u0026gt;current_slab = NULL; } else {// 获取下一个slab，并将current_slab设置为它，然后从链表中删除 struct slab_header *slab; slab = list_entry(slab_list-\u0026gt;next, struct slab_header, node); pool-\u0026gt;current_slab = slab; list_del(slab_list-\u0026gt;next); } /* BLANK END */ /* LAB 2 TODO 2 END */ } alloc_in_slab_impl函数，在slab中获取一个空闲空间\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 static void *alloc_in_slab_impl(int order) { struct slab_header *current_slab; struct slab_slot_list *free_list; void *next_slot; UNUSED(next_slot); lock(\u0026amp;slabs_locks[order]); current_slab = slab_pool[order].current_slab; /* When serving the first allocation request. */ if (unlikely(current_slab == NULL)) { // 当这个slab没有被初始化时，先初始化 current_slab = init_slab_cache(order, SIZE_OF_ONE_SLAB); if (current_slab == NULL) { // 初始化失败返回空 unlock(\u0026amp;slabs_locks[order]); return NULL; } slab_pool[order].current_slab = current_slab; } /* LAB 2 TODO 2 BEGIN */ /* * Hint: Find a free slot from the free list of current slab. * If current slab is full, choose a new slab as the current one. */ /* BLANK BEGIN */ free_list = (struct slab_slot_list *)(current_slab-\u0026gt;free_list_head); BUG_ON(free_list == NULL); next_slot = free_list-\u0026gt;next_free; // 获得下一个空闲slot current_slab-\u0026gt;free_list_head = next_slot; // 将head设置为next current_slab-\u0026gt;current_free_cnt -= 1; // 空闲减一 // 如果分配完这次之后没有可分配的空间了，就将下一个slab的换上来 if (unlikely(current_slab-\u0026gt;current_free_cnt == 0)) choose_new_current_slab(\u0026amp;(slab_pool[order])); /* BLANK END */ /* LAB 2 TODO 2 END */ unlock(\u0026amp;slabs_locks[order]); return (void *)free_list; } // 这里形成闭环，当所有的slab分配完之后，我们调用choose_new_current_slab就会将current_slab设置为NULL，再次调用这个函数时就又会从伙伴系统中分配一个slab free_in_slab函数，释放已分配的slot\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 void free_in_slab(void *addr) { struct page *page; struct slab_header *slab; struct slab_slot_list *slot; int order; slot = (struct slab_slot_list *)addr; page = virt_to_page(addr); if (!page) { kdebug(\u0026#34;invalid page in %s\u0026#34;, __func__); return; } slab = page-\u0026gt;slab; // 获取对应的slab order = slab-\u0026gt;order; lock(\u0026amp;slabs_locks[order]); try_insert_full_slab_to_partial(slab); #if ENABLE_DETECTING_DOUBLE_FREE_IN_SLAB == ON /* * SLAB double free detection: check whether the slot to free is * already in the free list. */ if (check_slot_is_free(slab, slot) == 1) { kinfo(\u0026#34;SLAB: double free detected. Address is %p\\n\u0026#34;, (unsigned long)slot); BUG_ON(1); } #endif /* LAB 2 TODO 2 BEGIN */ /* * Hint: Free an allocated slot and put it back to the free list. */ /* BLANK BEGIN */ // 类似于链栈操作 slot-\u0026gt;next_free = slab-\u0026gt;free_list_head; slab-\u0026gt;free_list_head = slot; slab-\u0026gt;current_free_cnt += 1; /* BLANK END */ /* LAB 2 TODO 2 END */ try_return_slab_to_buddy(slab, order); unlock(\u0026amp;slabs_locks[order]); } 练习题 3 完成 kernel/mm/kmalloc.c 中的 _kmalloc 函数中的 LAB 2 TODO 3 部分，在适当位置调用对应的函数，实现 kmalloc 功能\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 void *_kmalloc(size_t size, bool is_record, size_t *real_size) { void *addr = NULL; int order; if (unlikely(size == 0)) return ZERO_SIZE_PTR; if (size \u0026lt;= SLAB_MAX_SIZE) { /* LAB 2 TODO 3 BEGIN */ /* Step 1: Allocate in slab for small requests. */ /* BLANK BEGIN */ // 通过查看alloc_in_slab函数，发现只需要将参数传进去 addr = alloc_in_slab(size, real_size); /* BLANK END */ #if ENABLE_MEMORY_USAGE_COLLECTING == ON if (is_record \u0026amp;\u0026amp; collecting_switch) { record_mem_usage(*real_size, addr); } #endif } else { /* Step 2: Allocate in buddy for large requests. */ /* BLANK BEGIN */ // // 我们可以手搓获取order，但参考alloc_in_slab // 我们发现已经有一个size_to_page_order的方法 order = size_to_page_order(size); addr = get_pages(order); /* BLANK END */ /* LAB 2 TODO 3 END */ } BUG_ON(!addr); return addr; } 练习题4 完成 kernel/arch/aarch64/mm/page_table.c 中的 query_in_pgtbl、map_range_in_pgtbl_common、unmap_range_in_pgtbl 和 mprotect_in_pgtbl 函数中的 LAB 2 TODO 4 部分，分别实现页表查询、映射、取消映射和修改页表权限的操作，以 4KB 页为粒度。\n前置代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 typedef union { struct { u64 is_valid : 1, is_table : 1, ignored1 : 10, next_table_addr : 36, reserved : 4, ignored2 : 7, PXNTable : 1, // Privileged Execute-never for next level XNTable : 1, // Execute-never for next level APTable : 2, // Access permissions for next level NSTable : 1; } table; struct { u64 is_valid : 1, is_table : 1, attr_index : 3, // Memory attributes index NS : 1, // Non-secure AP : 2, // Data access permissions SH : 2, // Shareability AF : 1, // Accesss flag nG : 1, // Not global bit reserved1 : 4, nT : 1, reserved2 : 13, pfn : 18, reserved3 : 2, GP : 1, reserved4 : 1, DBM : 1, // Dirty bit modifier Contiguous : 1, PXN : 1, // Privileged execute-never UXN : 1, // Execute never soft_reserved : 4, PBHA : 4; // Page based hardware attributes } l1_block; struct { u64 is_valid : 1, is_table : 1, attr_index : 3, // Memory attributes index NS : 1, // Non-secure AP : 2, // Data access permissions SH : 2, // Shareability AF : 1, // Accesss flag nG : 1, // Not global bit reserved1 : 4, nT : 1, reserved2 : 4, pfn : 27, reserved3 : 2, GP : 1, reserved4 : 1, DBM : 1, // Dirty bit modifier Contiguous : 1, PXN : 1, // Privileged execute-never UXN : 1, // Execute never soft_reserved : 4, PBHA : 4; // Page based hardware attributes } l2_block; struct { u64 is_valid : 1, is_page : 1, attr_index : 3, // Memory attributes index NS : 1, // Non-secure AP : 2, // Data access permissions SH : 2, // Shareability AF : 1, // Accesss flag nG : 1, // Not global bit pfn : 36, reserved : 3, DBM : 1, // Dirty bit modifier Contiguous : 1, PXN : 1, // Privileged execute-never UXN : 1, // Execute never soft_reserved : 4, PBHA : 4, // Page based hardware attributes ignored : 1; } l3_page; u64 pte; } pte_t; // 页表项联合体，增加代码可读性 typedef struct { pte_t ent[PTP_ENTRIES]; } ptp_t; // 页表结构体，每个页表有512个页表项 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 /* cur_ptp: 当前页表地址 level: 当前页表级别 va: 虚拟地址 next_ptp: 下一级页表地址 pte: 返回的页表项地址 alloc: 如果页表项不合法时是否分配 rss: 用于记录内存占用 */ static int get_next_ptp(ptp_t *cur_ptp, u32 level, vaddr_t va, ptp_t **next_ptp, pte_t **pte, bool alloc, __maybe_unused long *rss) { u32 index = 0; pte_t *entry; if (cur_ptp == NULL) return -ENOMAPPING; switch (level) { case L0: index = GET_L0_INDEX(va); break; case L1: index = GET_L1_INDEX(va); break; case L2: index = GET_L2_INDEX(va); break; case L3: index = GET_L3_INDEX(va); break; default: BUG(\u0026#34;unexpected level\\n\u0026#34;); return -EINVAL; } entry = \u0026amp;(cur_ptp-\u0026gt;ent[index]); // 获取页表项 if (IS_PTE_INVALID(entry-\u0026gt;pte)) { // ... 省略n行 } // 获取页表项对应的页表地址（也有可能是一个块） *next_ptp = (ptp_t *)GET_NEXT_PTP(entry); // 返回下一级页表地址 *pte = entry; // 将获取到的页表项返回 if (IS_PTE_TABLE(entry-\u0026gt;pte)) // 判断是块还是页表 return NORMAL_PTP; else return BLOCK_PTP; } 题解：\nquery_in_pgtbl函数， 将虚拟地址翻译成物理地址，并返回存储该物理地址的页表项\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 /* pgtbl: L0页表地址 va: 虚拟地址 pa: 物理地址 entry: 存储该物理地址的页表项 */ int query_in_pgtbl(void *pgtbl, vaddr_t va, paddr_t *pa, pte_t **entry) { /* LAB 2 TODO 4 BEGIN */ /* * Hint: Walk through each level of page table using `get_next_ptp`, * return the pa and pte until a L2/L3 block or page, return * `-ENOMAPPING` if the va is not mapped. */ /* BLANK BEGIN */ ptp_t *l0_ptp, *l1_ptp, *l2_ptp, *l3_ptp; ptp_t *phys_p; pte_t *pte; int ret; // 翻译0级页表，获得1级页表地址 l0_ptp = (ptp_t *)pgtbl; ret = get_next_ptp(l0_ptp, 0, va, \u0026amp;l1_ptp, \u0026amp;pte, false, NULL); BUG_ON(ret != NORMAL_PTP); // 题目描述是以4KB为粒度，所以不考虑块地址 // 翻译1级页表，获得2级页表地址 ret = get_next_ptp(l1_ptp, 1, va, \u0026amp;l2_ptp, \u0026amp;pte, false, NULL); BUG_ON(ret != NORMAL_PTP); // 翻译2级页表，获得3级页表地址 ret = get_next_ptp(l2_ptp, 2, va, \u0026amp;l3_ptp, \u0026amp;pte, false, NULL); BUG_ON(ret != NORMAL_PTP); // 翻译3级页表，获得物理页地址 ret = get_next_ptp(l3_ptp, 3, va, \u0026amp;phys_p, \u0026amp;pte, false, NULL); if (ret \u0026lt; 0) return ret; // 此时phys_p为物理页地址，而操作系统也只能通过虚拟地址访问内存 // get_next_ptp默认将物理地址转为虚拟地址返回 // 所以我们要将得到的虚拟地址先转为物理地址 // 最后，我们要再加上偏移值 if (pa) *pa = virt_to_phys(phys_p) + GET_VA_OFFSET_L3(va); if (entry) *entry = pte; /* BLANK END */ /* LAB 2 TODO 4 END */ return 0; } map_range_in_pgtbl_common函数，建立页表映射\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 /* pgtbl: L0页表地址 va: 虚拟地址(起始) pa: 物理地址(起始) len: 映射大小 flag: 权限标识，在set_pte_flags中用到 kind: 页表类型，0代表用户态页表，1代表内核页表 rss: 跟踪内存占用 */ static int map_range_in_pgtbl_common(void *pgtbl, vaddr_t va, paddr_t pa, size_t len, vmr_prop_t flags, int kind, __maybe_unused long *rss) { /* LAB 2 TODO 4 BEGIN */ /* * Hint: Walk through each level of page table using `get_next_ptp`, * create new page table page if necessary, fill in the final level * pte with the help of `set_pte_flags`. Iterate until all pages are * mapped. * Since we are adding new mappings, there is no need to flush TLBs. * Return 0 on success. */ /* BLANK BEGIN */ u64 total_page_cnt; ptp_t *l0_ptp, *l1_ptp, *l2_ptp, *l3_ptp; pte_t *pte; int ret, pte_idx, i; BUG_ON(pgtbl == NULL); // 由于映射单位是按页来分的，页内偏移量应该为0 BUG_ON(va % PAGE_SIZE); // 计算需要的页表数量 total_page_cnt = len / PAGE_SIZE + (len % PAGE_SIZE \u0026gt; 0 ? 1 : 0); l0_ptp = (ptp_t *)pgtbl; // while (total_page_cnt \u0026gt; 0) { // 先一路翻译到l3页表，如果页表不存在则先分配一个页表 ret = get_next_ptp(l0_ptp, 0, va, \u0026amp;l1_ptp, \u0026amp;pte, true, rss); BUG_ON(ret != NORMAL_PTP); ret = get_next_ptp(l1_ptp, 1, va, \u0026amp;l2_ptp, \u0026amp;pte, true, rss); BUG_ON(ret != NORMAL_PTP); ret = get_next_ptp(l2_ptp, 2, va, \u0026amp;l3_ptp, \u0026amp;pte, true, rss); BUG_ON(ret != NORMAL_PTP); // 获取页表项的位置 pte_idx = GET_L3_INDEX(va); // 从该位置开始循环地分配页表项 for (i = pte_idx; i \u0026lt; PTP_ENTRIES; i++) { // 配置l3页表项 pte_t new_pte; new_pte.pte = 0; // 这里是为了初始化 new_pte.l3_page.is_valid = 1; new_pte.l3_page.is_page = 1; // 获取页表项映射的物理地址位置 new_pte.l3_page.pfn = pa \u0026gt;\u0026gt; PAGE_SHIFT; // 设置内存权限 set_pte_flags(\u0026amp;new_pte, flags, kind); // 赋值给l3页表对应的位置 l3_ptp-\u0026gt;ent[i].pte = new_pte.pte; // 这里是为了保证下一次循环能够正确的得到起始的va和pa va += PAGE_SIZE; pa += PAGE_SIZE; if (rss) // 记录内存占用 *rss += PAGE_SIZE; total_page_cnt -= 1; // 所需页表数减1 if (total_page_cnt == 0) // 如果已经分配完毕则退出 break; } } /* BLANK END */ /* LAB 2 TODO 4 END */ // 用于保障共享资源的更新 dsb(ishst); // 确保所有之前的内存操作已完成 isb(); // 刷新指令流水线 return 0; } unmap_range_in_pgtbl函数，取消内存映射，是map_range_in_pgtbl_common的相反操作，我们只需要复制之后进行修改就好了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 int unmap_range_in_pgtbl(void *pgtbl, vaddr_t va, size_t len, __maybe_unused long *rss) { /* LAB 2 TODO 4 BEGIN */ /* * Hint: Walk through each level of page table using `get_next_ptp`, * mark the final level pte as invalid. Iterate until all pages are * unmapped. * You don\u0026#39;t need to flush tlb here since tlb is now flushed after * this function is called. * Return 0 on success. */ /* BLANK BEGIN */ u64 total_page_cnt; ptp_t *l0_ptp, *l1_ptp, *l2_ptp, *l3_ptp; pte_t *pte; int ret, pte_idx, i; BUG_ON(pgtbl == NULL); BUG_ON(va % PAGE_SIZE); total_page_cnt = len / PAGE_SIZE + (len % PAGE_SIZE \u0026gt; 0 ? 1 : 0); l0_ptp = (ptp_t *)pgtbl; while (total_page_cnt \u0026gt; 0) { ret = get_next_ptp(l0_ptp, 0, va, \u0026amp;l1_ptp, \u0026amp;pte, false, rss); if (ret == -ENOMAPPING) { // 这里与之前不同，当l0_ptp为0 // 或者对应的页表项不合法的时候才会返回-ENOMAPPING // 这意味着对应的内存已经被取消映射 // 我们只需要保证当前函数逻辑能继续运行下去就好 total_page_cnt -= L0_PER_ENTRY_PAGES; va += L0_PER_ENTRY_PAGES * PAGE_SIZE; if (rss) *rss -= L0_PER_ENTRY_PAGES * PAGE_SIZE; continue; } ret = get_next_ptp(l1_ptp, 1, va, \u0026amp;l2_ptp, \u0026amp;pte, false, rss); if (ret == -ENOMAPPING) { // 同上 total_page_cnt -= L1_PER_ENTRY_PAGES; va += L1_PER_ENTRY_PAGES * PAGE_SIZE; if (rss) *rss -= L1_PER_ENTRY_PAGES * PAGE_SIZE; continue; } ret = get_next_ptp(l2_ptp, 2, va, \u0026amp;l3_ptp, \u0026amp;pte, false, rss); if (ret == -ENOMAPPING) { // 同上 total_page_cnt -= L2_PER_ENTRY_PAGES; va += L2_PER_ENTRY_PAGES * PAGE_SIZE; if (rss) *rss -= L2_PER_ENTRY_PAGES * PAGE_SIZE; continue; } // 获取l3页表项的下标 pte_idx = GET_L3_INDEX(va); for (i = pte_idx; i \u0026lt; PTP_ENTRIES; i++) { l3_ptp-\u0026gt;ent[i].pte = 0; // 直接将所有值都设置为0即可 // 同 map_range_in_pgtbl_common va += PAGE_SIZE; if (rss) // 记录内存占用 *rss -= PAGE_SIZE; total_page_cnt -= 1; if (total_page_cnt == 0) break; } } /* BLANK END */ /* LAB 2 TODO 4 END */ dsb(ishst); isb(); return 0; } mprotect_in_pgtbl函数，跟上面一样，只需要改一两句代码，没什么好讲的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 int mprotect_in_pgtbl(void *pgtbl, vaddr_t va, size_t len, vmr_prop_t flags) { /* LAB 2 TODO 4 BEGIN */ /* * Hint: Walk through each level of page table using `get_next_ptp`, * modify the permission in the final level pte using `set_pte_flags`. * The `kind` argument of `set_pte_flags` should always be `USER_PTE`. * Return 0 on success. */ /* BLANK BEGIN */ u64 total_page_cnt; ptp_t *l0_ptp, *l1_ptp, *l2_ptp, *l3_ptp; pte_t *pte; int ret, pte_idx, i; BUG_ON(pgtbl == NULL); BUG_ON(va % PAGE_SIZE); total_page_cnt = len / PAGE_SIZE + (len % PAGE_SIZE \u0026gt; 0 ? 1 : 0); l0_ptp = (ptp_t *)pgtbl; while (total_page_cnt \u0026gt; 0) { ret = get_next_ptp(l0_ptp, 0, va, \u0026amp;l1_ptp, \u0026amp;pte, false, NULL); if (ret == -ENOMAPPING) { total_page_cnt -= L0_PER_ENTRY_PAGES; va += L0_PER_ENTRY_PAGES * PAGE_SIZE; continue; } ret = get_next_ptp(l1_ptp, 1, va, \u0026amp;l2_ptp, \u0026amp;pte, false, NULL); if (ret == -ENOMAPPING) { total_page_cnt -= L1_PER_ENTRY_PAGES; va += L1_PER_ENTRY_PAGES * PAGE_SIZE; continue; } ret = get_next_ptp(l2_ptp, 2, va, \u0026amp;l3_ptp, \u0026amp;pte, false, NULL); if (ret == -ENOMAPPING) { total_page_cnt -= L2_PER_ENTRY_PAGES; va += L2_PER_ENTRY_PAGES * PAGE_SIZE; continue; } pte_idx = GET_L3_INDEX(va); for (i = pte_idx; i \u0026lt; PTP_ENTRIES; i++) { set_pte_flags(\u0026amp;(l3_ptp-\u0026gt;ent[i]), flags, USER_PTE); va += PAGE_SIZE; total_page_cnt -= 1; if (total_page_cnt == 0) break; } } /* BLANK END */ /* LAB 2 TODO 4 END */ return 0; } 挑战题7 使用前面实现的 page_table.c 中的函数，在内核启动后的 main 函数中重新配置内核页表，进行细粒度的映射。\n这题的意思应该是将所有的内核地址都映射到内核页表内，这需要根据lab1中的介绍来获取内核地址范围。但由于笔者实力不够，还不太明白这题的意思，并且没有多少时间来钻研这个，所以并没有进行实现\n练习题 8, 9, 10 完成 kernel/arch/aarch64/irq/pgfault.c 中的 do_page_fault 函数中的 LAB 2 TODO 5 部分，将缺页异常转发给 handle_trans_fault 函数。 完成 kernel/mm/vmspace.c 中的 find_vmr_for_va 函数中的 LAB 2 TODO 6 部分，找到一个虚拟地址找在其虚拟地址空间中的 VMR。 完成 kernel/mm/pgfault_handler.c 中的 handle_trans_fault 函数中的 LAB 2 TODO 7 部分（函数内共有 3 处填空，不要遗漏），实现 PMO_SHM 和 PMO_ANONYM 的按需物理页分配。你可以阅读代码注释，调用你之前见到过的相关函数来实现功能。 以上三题基本等于一题，所以放一起看\ndo_page_fault 函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 void do_page_fault(u64 esr, u64 fault_ins_addr, int type, u64 *fix_addr) { vaddr_t fault_addr; int fsc; // fault status code int wnr; int ret = 0; fault_addr = get_fault_addr(); // 获取缺页异常的地址时要访问的地址 fsc = GET_ESR_EL1_FSC(esr);\t// 获取缺页异常类型 switch (fsc) { case DFSC_TRANS_FAULT_L0: case DFSC_TRANS_FAULT_L1: case DFSC_TRANS_FAULT_L2: case DFSC_TRANS_FAULT_L3: { /* LAB 2 TODO 5 BEGIN */ /* BLANK BEGIN */ // 根据上下文，这是一个翻译异常，所以我们参考下面的权限异常来调用异常处理函数 ret = handle_trans_fault(current_thread-\u0026gt;vmspace, fault_addr); /* BLANK END */ /* LAB 2 TODO 5 END */ if (ret != 0) { /* The trap happens in the kernel */ if (type \u0026lt; SYNC_EL0_64) { goto no_context; } kinfo(\u0026#34;do_page_fault: faulting ip is 0x%lx (real IP),\u0026#34; \u0026#34;faulting address is 0x%lx,\u0026#34; \u0026#34;fsc is trans_fault (0b%b),\u0026#34; \u0026#34;type is %d\\n\u0026#34;, fault_ins_addr, fault_addr, fsc, type); kprint_vmr(current_thread-\u0026gt;vmspace); kinfo(\u0026#34;current_cap_group is %s\\n\u0026#34;, current_cap_group-\u0026gt;cap_group_name); sys_exit_group(-1); } break; } // ...省略n行 } find_vmr_for_va 函数，在vmspace中查找相应vmr\n​\t前置代码：\n对应的结构体定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 struct vmregion { struct list_head list_node; /* As one node of the vmr_list */ struct rb_node tree_node; /* As one node of the vmr_tree */ /* As one node of the pmo\u0026#39;s mapping_list */ struct list_head mapping_list_node; struct vmspace *vmspace; // 所在用户态空间 vaddr_t start; // 地址段起始位置 size_t size; // 地址段大小 /* Offset of underlying pmo */ size_t offset; vmr_prop_t perm; // 地址段权限 struct pmobject *pmo; // 物理内存对象 struct list_head cow_private_pages; // 由copy-on-write使用 }; /* This struct represents one virtual address space */ struct vmspace { // 用户态空间 /* List head of vmregion (vmr_list) */ struct list_head vmr_list; // 用户态地址段链表 /* rbtree root node of vmregion (vmr_tree) */ struct rb_root vmr_tree; // 用户态地址段红黑树，用于快速查找相应地址 /* Root page table */ void *pgtbl; // L0页表地址 /* Address space ID for avoiding TLB conflicts */ unsigned long pcid; // 用户id /* The lock for manipulating vmregions */ struct lock vmspace_lock; /* The lock for manipulating the page table */ struct lock pgtbl_lock; /* * For TLB flushing: * Record the all the CPU that a vmspace ran on. */ unsigned char history_cpus[PLAT_CPU_NUM]; struct vmregion *heap_boundary_vmr; // 没用到，感兴趣可以通过vsc的搜索功能看一下用法 /* Records size of memory mapped. Protected by pgtbl_lock. */ long rss; // 内存管理标志 }; 红黑树的查询函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 struct rb_node *rb_search(struct rb_root *this, const void *key, comp_key_func cmp) { struct rb_node *cur = this-\u0026gt;root_node; int cmp_ret; while (cur) { cmp_ret = cmp(key, cur); if (cmp_ret \u0026lt; 0) { cur = cur-\u0026gt;left_child; } else if (cmp_ret \u0026gt; 0) { cur = cur-\u0026gt;right_child; } else { return cur; } } return NULL; } ​\t题解：\n我们其实不需要了解太多相关信息，只需要知道怎么查找就好了，这里使用的是红黑树来查找，根据内核实现的红黑树查找函数，以及已经实现了的比较函数cmp_vmr_and_va和rb_entry，即可完成题目\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 __maybe_unused struct vmregion *find_vmr_for_va(struct vmspace *vmspace, vaddr_t addr) { /* LAB 2 TODO 6 BEGIN */ /* Hint: Find the corresponding vmr for @addr in @vmspace */ /* BLANK BEGIN */ struct vmregion *vmr; struct rb_node *node; node = rb_search( // 查找相应的节点 \u0026amp;(vmspace-\u0026gt;vmr_tree), (const void *)addr, cmp_vmr_and_va); if (unlikely(node == NULL)) { // 没找到返回NULL return NULL; } vmr = rb_entry(node, struct vmregion, tree_node); // 获取节点所在结构体 return vmr; /* BLANK END */ /* LAB 2 TODO 6 END */ } handle_trans_fault 函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 int handle_trans_fault(struct vmspace *vmspace, vaddr_t fault_addr) { struct vmregion *vmr; struct pmobject *pmo; paddr_t pa; unsigned long offset; unsigned long index; int ret = 0; /* * Grab lock here. * Because two threads (in same process) on different cores * may fault on the same page, so we need to prevent them * from adding the same mapping twice. */ lock(\u0026amp;vmspace-\u0026gt;vmspace_lock); vmr = find_vmr_for_va(vmspace, fault_addr); // 查找对应vmr if (vmr == NULL) { // 如果为空则该地址不合法，直接退出 kinfo(\u0026#34;handle_trans_fault: no vmr found for va 0x%lx!\\n\u0026#34;, fault_addr); dump_pgfault_error(); unlock(\u0026amp;vmspace-\u0026gt;vmspace_lock); #if defined(CHCORE_ARCH_AARCH64) || defined(CHCORE_ARCH_SPARC) /* kernel fault fixup is only supported on AArch64 and Sparc */ return -EFAULT; #endif sys_exit_group(-1); BUG(\u0026#34;should not reach here\u0026#34;); } pmo = vmr-\u0026gt;pmo; // 获取物理内存对象 /* Get the offset in the pmo for faulting addr */ offset = ROUND_DOWN(fault_addr, PAGE_SIZE) - vmr-\u0026gt;start + vmr-\u0026gt;offset; vmr_prop_t perm = vmr-\u0026gt;perm; // 获取权限记录 switch (pmo-\u0026gt;type) { // 根据内存对象类型进行处理 case PMO_ANONYM: case PMO_SHM: { /* Boundary check */ BUG_ON(offset \u0026gt;= pmo-\u0026gt;size); /* Get the index in the pmo radix for faulting addr */ index = offset / PAGE_SIZE; // 处理fault_addr，去除页内偏移以便后续处理 fault_addr = ROUND_DOWN(fault_addr, PAGE_SIZE); pa = get_page_from_pmo(pmo, index); // 从pmo中获取物理地址 if (pa == 0) { // 如果地址为空，则为未分配，我们直接分配即可 /* * Not committed before. Then, allocate the physical * page. */ /* LAB 2 TODO 7 BEGIN */ /* BLANK BEGIN */ /* Hint: Allocate a physical page and clear it to 0. */ void *new_va = get_pages(0); // 获取一个页 BUG_ON(new_va == NULL); pa = virt_to_phys(new_va); // 转化为物理地址 BUG_ON(pa == 0); memset((char *)new_va, 0, PAGE_SIZE); // 将页内清空 /* BLANK END */ /* * Record the physical page in the radix tree: * the offset is used as index in the radix tree */ kdebug(\u0026#34;commit: index: %ld, 0x%lx\\n\u0026#34;, index, pa); commit_page_to_pmo(pmo, index, pa); /* Add mapping in the page table */ lock(\u0026amp;vmspace-\u0026gt;pgtbl_lock); /* BLANK BEGIN */ // 将地址映射到页表中 map_range_in_pgtbl(vmspace-\u0026gt;pgtbl, fault_addr, pa, PAGE_SIZE, perm, \u0026amp;(vmspace-\u0026gt;rss)); /* BLANK END */ unlock(\u0026amp;vmspace-\u0026gt;pgtbl_lock); } else { if (pmo-\u0026gt;type == PMO_SHM || pmo-\u0026gt;type == PMO_ANONYM) { /* Add mapping in the page table */ lock(\u0026amp;vmspace-\u0026gt;pgtbl_lock); /* BLANK BEGIN */ // 此时内存已被分配，只是没有映射页表，只需要映射页表 map_range_in_pgtbl(vmspace-\u0026gt;pgtbl, fault_addr, pa, PAGE_SIZE, perm, \u0026amp;(vmspace-\u0026gt;rss)); /* BLANK END */ /* LAB 2 TODO 7 END */ unlock(\u0026amp;vmspace-\u0026gt;pgtbl_lock); } } if (perm \u0026amp; VMR_EXEC) { arch_flush_cache(fault_addr, PAGE_SIZE, SYNC_IDCACHE); } break; } //...省略n行 } 挑战题 11 我们在map_range_in_pgtbl_common、unmap_range_in_pgtbl 函数中预留了没有被使用过的参数rss 用来来统计map映射中实际的物理内存使用量1， 你需要修改相关的代码来通过Compute physical memory测试，不实现该挑战题并不影响其他部分功能的实现及测试。如果你想检测是否通过此部分测试，需要修改kernel/config.cmake中CHCORE_KERNEL_PM_USAGE_TEST为ON\n题解：在上面的实现中笔者已经实现了大部分的内存记录，此时只需要稍作修改\nget_next_ptp 函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 if (IS_PTE_INVALID(entry-\u0026gt;pte)) { if (alloc == false) { return -ENOMAPPING; } else { /* alloc a new page table page */ ptp_t *new_ptp; paddr_t new_ptp_paddr; pte_t new_pte_val; /* alloc a single physical page as a new page table page */ new_ptp = get_pages(0); if (new_ptp == NULL) return -ENOMEM; memset((void *)new_ptp, 0, PAGE_SIZE); new_ptp_paddr = virt_to_phys((vaddr_t)new_ptp); new_pte_val.pte = 0; new_pte_val.table.is_valid = 1; new_pte_val.table.is_table = 1; new_pte_val.table.next_table_addr = new_ptp_paddr \u0026gt;\u0026gt; PAGE_SHIFT; /* same effect as: cur_ptp-\u0026gt;ent[index] = new_pte_val; */ entry-\u0026gt;pte = new_pte_val.pte; // 只需要在这里加一个内存记录 if (rss) *rss += PAGE_SIZE; } } try_release_ptp 函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 static int try_release_ptp(ptp_t *high_ptp, ptp_t *low_ptp, int index, __maybe_unused long *rss) { int i; for (i = 0; i \u0026lt; PTP_ENTRIES; i++) { if (low_ptp-\u0026gt;ent[i].pte != PTE_DESCRIPTOR_INVALID) { return 0; } } BUG_ON(index \u0026lt; 0 || index \u0026gt;= PTP_ENTRIES); high_ptp-\u0026gt;ent[index].pte = PTE_DESCRIPTOR_INVALID; kfree(low_ptp); if (rss) // 加一个内存记录 *rss -= PAGE_SIZE; return 1; } unmap_range_in_pgtbl函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 pte_idx = GET_L3_INDEX(va); pre_va = va; // 先记录原来的地址 for (i = pte_idx; i \u0026lt; PTP_ENTRIES; i++) { l3_ptp-\u0026gt;ent[i].pte = PTE_DESCRIPTOR_INVALID; va += PAGE_SIZE; if (rss) *rss -= PAGE_SIZE; total_page_cnt -= 1; if (total_page_cnt == 0) { // 如果此时已经将所有的页表取消了映射，调用页表回收函数，已经被实现 recycle_pgtable_entry(l0_ptp, l1_ptp, l2_ptp, l3_ptp, pre_va, rss); break; } } // 每次大循环都要回收尝试回收一次页表 if (total_page_cnt != 0) // 防止多次调用回收函数导致计算错误，所以要先判断 recycle_pgtable_entry(l0_ptp, l1_ptp, l2_ptp, l3_ptp, pre_va, rss); ","date":"2024-11-24T16:26:44+08:00","permalink":"http://localhost:1313/blogs/chcore_lab1-%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0/","title":"ChCore_lab1 做题笔记"},{"content":"简介 文档链接：Lab1: 机器启动 - IPADS OS Course Lab Manual\n本实验作为 ChCore 操作系统课程实验的第一个实验，分为三个部分。\nRTFSC: 代码导读，由于是Lab1，我们主要注重于Chcore的构建系统，这部分没有习题。 机器启动：介绍aarch64结构启动时的关键寄存器以及关键的启动函数。 页表配置：介绍aarch64页表结构，以及针对树莓派3平台的内存布局编写页表配置。 调试指北\n在开始实验之前，请务必读完调试指北，以帮助你快速上手调试。\n思考题 1 阅读 _start 函数的开头，尝试说明 ChCore 是如何让其中一个核首先进入初始化流程，并让其他核暂停执行的。\n1 2 3 4 # the begin of _start mrs\tx8, mpidr_el1 and\tx8, x8,\t#0xFF cbz\tx8, primary 从中我们可以知道，在函数的开头会从mpidr_el1寄存器中读取cpu的编号，当cpu的编号为0时（即当前核心是主核心时）就会跳转到primary进行初始化\n练习2 在 arm64_elX_to_el1 函数的 LAB 1 TODO 1 处填写一行汇编代码，获取 CPU 当前异常级别。\narm64_elX_to_el1，顾名思义，从特权级elX降级到el1，其中X代表任意特权级\n根据ChCore文档中的提示，我们可以从CurrentEL寄存器中获取当前的特权级，又根据Arm文档中的介绍：\n我们可以很简单的知道，应该把CurrentEL中的值获取到x9寄存器里，即\n1 2 3 4 5 6 7 8 9 10 11 12 13 # the begin of arm64_elX_to_el1 /* LAB 1 TODO 1 BEGIN */ /* BLANK BEGIN */ mrs x9, CurrentEL /* BLANK END */ /* LAB 1 TODO 1 END */ // Check the current exception level. cmp x9, CURRENTEL_EL1 beq .Ltarget cmp x9, CURRENTEL_EL2 beq .Lin_el2 练习题 3 eret指令可用于从高异常级别跳到更低的异常级别，在执行它之前我们需要设置 设置 elr_elx（异常链接寄存器）和 spsr_elx（保存的程序状态寄存器），分别控制eret执行后的指令地址（PC）和程序状态（包括异常返回后的异常级别）。\n在 arm64_elX_to_el1 函数的 LAB 1 TODO 2 处填写大约 4 行汇编代码，设置从 EL3 跳转到 EL1 所需的 elr_el3 和 spsr_el3 寄存器值。\nelr_el3 的正确设置应使得控制流在 eret 后从 arm64_elX_to_el1 返回到 _start 继续执行初始化。 spsr_el3 的正确设置应正确屏蔽 DAIF 四类中断，并且将 SP 正确设置为 EL1h. 在设置好这两个系统寄存器后，不需要立即 eret.\nelr_el3，参考el1时的操作，从el3返回el1时同样应该回到.Ltarget处来返回\n可以通过指令adr，获取标签的地址并存入寄存器中\nspsr_el3，根据下图\n并且结合arm文档中的解释：Inject Undefined Instruction exception. Set to 0 on taking an exception to EL3, and copied to PSTATE.UINJ on executing an exception return operation in EL3.（注入未定义的指令异常。将异常带入 EL3 时设置为 0，在 EL3 中执行异常返回操作时复制到 PSTATE.UINJ。）\nDAIF四类中断的位数是 [9:6]，而M[3:0]指定返回特权级的sp指针\n由于lab1贴心的定义好了相应的变量，我们直接使用变量就好了\n1 2 3 4 5 6 7 8 9 # Set the return address and exception level. /* LAB 1 TODO 2 BEGIN */ /* BLANK BEGIN */ adr x9, .Ltarget msr elr_el3, x9 mov x9, SPSR_ELX_DAIF | SPSR_ELX_EL1H msr spsr_el3, x9 /* BLANK END */ /* LAB 1 TODO 2 END */ 思考题 4 说明为什么要在进入 C 函数之前设置启动栈。如果不设置，会发生什么？\n因为调用函数需要使用到栈来保存状态，如果不启用栈，会导致函数调用失败\n思考题 5 在实验 1 中，其实不调用 clear_bss 也不影响内核的执行，请思考不清理 .bss 段在之后的何种情况下会导致内核无法工作\n当内核中的某个函数依赖全局变量的初始值为0时，不清理.bss可能会导致出现无法预料的异常\n练习题6 在 kernel/arch/aarch64/boot/raspi3/peripherals/uart.c 中 LAB 1 TODO 3 处实现通过 UART 输出字符串的逻辑。\n1 2 3 4 5 6 7 8 9 void uart_send_string(char *str) { /* LAB 1 TODO 3 BEGIN */ /* BLANK BEGIN */ for (int i = 0; str[i] != 0; i++) early_uart_send(str[i]); /* BLANK END */ /* LAB 1 TODO 3 END */ } 练习题7 在 kernel/arch/aarch64/boot/raspi3/init/tools.S 中 LAB 1 TODO 4 处填写一行汇编代码，以启用 MMU。\n我们可以在kernel/include/arch/aarch64/arch/machine/registers.h中找到相应的变量定义\n很容易知道应该答案：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 mrs x8, sctlr_el1 /* Enable MMU */ /* LAB 1 TODO 4 BEGIN */ /* BLANK BEGIN */ orr\tx8, x8, #SCTLR_EL1_M /* BLANK END */ /* LAB 1 TODO 4 END */ /* Disable alignment checking */ bic x8, x8, #SCTLR_EL1_A bic x8, x8, #SCTLR_EL1_SA0 bic x8, x8, #SCTLR_EL1_SA orr x8, x8, #SCTLR_EL1_nAA /* Data accesses Cacheable */ orr x8, x8, #SCTLR_EL1_C /* Instruction access Cacheable */ orr x8, x8, #SCTLR_EL1_I msr sctlr_el1, x8 这里关闭了对齐检查，启用了指令和数据缓存\n变量SCTLR_EL1_M表示启动MMU\n思考题 8 请思考多级页表相比单级页表带来的优势和劣势（如果有的话），并计算在 AArch64 页表中分别以 4KB 粒度和 2MB 粒度映射 0～4GB 地址范围所需的物理内存大小（或页表页数量）。\n多级页表优势是不需要一次性地将所有空间都映射，尽管在映射大空间时占用内存多，但一般场景下需要映射地空间都很小，减少了内存的浪费。劣势是翻译需要多次访问内存，性能较差。\n4KB粒度需要1024*1024个条目，则需要2048个3级页表，其中这2048个3级页表又需要4个2级页表项，总共需要2048+3个页表（考虑L0~L2）。\n2MB粒度下需要2048个条目，需要4个2级页表，总共需要4+2个页表（考虑L0~L1）。\ninit_kernel_pt 为内核配置从 0x00000000 到 0x80000000（0x40000000 后的 1G，ChCore 只需使用这部分地址中的本地外设）的映射，其中 0x00000000 到 0x3f000000 映射为 normal memory，0x3f000000 到 0x80000000映射为 device memory，其中 0x00000000 到 0x40000000 以 2MB 块粒度映射，0x40000000 到 0x80000000 以 1GB 块粒度映射。\n思考题 9 请结合上述地址翻译规则，计算在练习题 10 中，你需要映射几个 L2 页表条目，几个 L1 页表条目，几个 L0 页表条目。页表页需要占用多少物理内存？\n0x0000_0000到0x4000_0000总共1024G，以2MB为粒度，需要524288个L2条目，1024个L1条目，2个L0条目\n0x4000_0000到0x8000_0000总共1024G，以1G为粒度，需要1024个L1条目，需要2个L0条目\n总共1028*4KB内存（不考虑L0）\n练习题 10 在 init_kernel_pt 函数的 LAB 1 TODO 5 处配置内核高地址页表（boot_ttbr1_l0、boot_ttbr1_l1 和 boot_ttbr1_l2），以 2MB 粒度映射。\n这里低位和高位的映射都是一样的，我们可以直接copy低位的配置来直接修改\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /* TTBR1_EL1 0-1G */ /* LAB 1 TODO 5 BEGIN */ /* Step 1: set L0 and L1 page table entry */ /* BLANK BEGIN */ vaddr = KERNEL_VADDR + PHYSMEM_START; boot_ttbr1_l0[GET_L0_INDEX(vaddr)] = ((u64)boot_ttbr1_l1) | IS_TABLE | IS_VALID; boot_ttbr1_l1[GET_L1_INDEX(vaddr)] = ((u64)boot_ttbr1_l2) | IS_TABLE | IS_VALID; /* BLANK END */ /* Step 2: map PHYSMEM_START ~ PERIPHERAL_BASE with 2MB granularity */ /* BLANK BEGIN */ for (; vaddr \u0026lt; KERNEL_VADDR + PERIPHERAL_BASE; vaddr += SIZE_2M) { boot_ttbr1_l2[GET_L2_INDEX(vaddr)] = (vaddr - KERNEL_VADDR) | UXN /* Unprivileged execute never */ | ACCESSED /* Set access flag */ | INNER_SHARABLE /* Sharebility */ | NORMAL_MEMORY /* Normal memory */ | IS_VALID; } /* BLANK END */ /* Step 2: map PERIPHERAL_BASE ~ PHYSMEM_END with 2MB granularity */ /* BLANK BEGIN */ for (vaddr = KERNEL_VADDR + PERIPHERAL_BASE; vaddr \u0026lt; KERNEL_VADDR + PHYSMEM_END; vaddr += SIZE_2M) { boot_ttbr1_l2[GET_L2_INDEX(vaddr)] = (vaddr - KERNEL_VADDR) /* low mem, va = pa */ | UXN /* Unprivileged execute never */ | ACCESSED /* Set access flag */ | DEVICE_MEMORY /* Device memory */ | IS_VALID; } /* BLANK END */ /* LAB 1 TODO 5 END */ 将boot_ttbr0_lx改成boot_ttbr1_lx vaddr = KERNEL_VADDR + 物理地址 在进行映射时记得把 vaddr - KERNEL_VADDR 高地址只有内核执行，不需要通过ASID来区分，所以把所有的NG删掉 思考题11 请思考在 init_kernel_pt 函数中为什么还要为低地址配置页表，并尝试验证自己的解释。\n由于启动mmu之后的指令仍然在低地址中执行，如果不为低地址配置页表的话，就会翻译出错而trap在小于0x8000的地址段。直到运行到start_kernel函数时才会进入高地址运行\n思考题12 在一开始我们暂停了三个其他核心的执行，根据现有代码简要说明它们什么时候会恢复执行。思考为什么一开始只让 0 号核心执行初始化流程？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 void init_c(void) { /* Clear the bss area for the kernel image */ clear_bss(); /* Initialize UART before enabling MMU. */ early_uart_init(); uart_send_string(\u0026#34;boot: init_c\\r\\n\u0026#34;); wakeup_other_cores(); /* Initialize Kernell Page Table. */ uart_send_string(\u0026#34;[BOOT] Install kernel page table\\r\\n\u0026#34;); init_kernel_pt(); /* Enable MMU. */ el1_mmu_activate(); uart_send_string(\u0026#34;[BOOT] Enable el1 MMU\\r\\n\u0026#34;); /* Call Kernel Main. */ uart_send_string(\u0026#34;[BOOT] Jump to kernel main\\r\\n\u0026#34;); start_kernel(secondary_boot_flag); /* Never reach here */ } 根据init_c函数我们知道在初始化完串口之后，其它的核心就会被唤醒。使用一个核心有利于简化初始化过程，在串行的初始化中我们也容易知道出错的位置，从而更好地找到问题所在。并且在启动过程中，一些操作通常需要按特定顺序执行，包括时钟、调度器、锁等，使用单个核心可以更容易地控制这一过程。\n","date":"2024-11-17T16:26:44+08:00","permalink":"http://localhost:1313/blogs/chcore_lab1-%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0/","title":"ChCore_lab1 做题笔记"},{"content":"简介 ​\t在实验 0 中，你需要通过阅读汇编代码以及使用调试工具来拆除一个 二进制炸弹程序。本实验分为两个部分：第一部分介绍拆弹实验的基本知 识，包括 ARM 汇编语言、QEMU 模拟器、GDB 调试器的使用；第二部分 需要分析炸弹程序，推测正确的输入来使得炸弹程序能正常退出。\n文档链接：Lab0：拆炸弹 - IPADS OS Course Lab Manual\n军火展示（炸弹总览 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;stdio.h\u0026gt; #include \u0026#34;phases.h\u0026#34; #include \u0026#34;utils.h\u0026#34; int main() { char* input; printf(\u0026#34;Type in your defuse password!\\n\u0026#34;); input = read_line(); phase_0(input); phase_defused(); input = read_line(); phase_1(input); phase_defused(); input = read_line(); phase_2(input); phase_defused(); input = read_line(); phase_3(input); phase_defused(); input = read_line(); phase_4(input); phase_defused(); input = read_line(); phase_5(input); phase_defused(); printf(\u0026#34;Congrats! You have defused all phases!\\n\u0026#34;); return 0; } phase_0 1 2 3 4 5 6 7 8 9 10 11 12 0000000000400734 \u0026lt;phase_0\u0026gt;: 400734:\ta9bf7bfd stp\tx29, x30, [sp, #-16]! 400738:\t910003fd mov\tx29, sp 40073c:\t94000126 bl\t400bd4 \u0026lt;read_int\u0026gt; // 调用read_int函数读入一个整形 400740:\t90000501 adrp\tx1, 4a0000 \u0026lt;.got.plt+0x18\u0026gt; 400744:\tb9405421 ldr\tw1, [x1, #84] //获取0x4a0000+84中的值 400748:\t6b00003f cmp\tw1, w0\t//比较read_int的返回值与内存中获取的值 40074c:\t54000061 b.ne\t400758 \u0026lt;phase_0+0x24\u0026gt; //两者不相等就爆炸 400750:\ta8c17bfd ldp\tx29, x30, [sp], #16 400754:\td65f03c0 ret 400758:\t940000e7 bl\t400af4 \u0026lt;explode\u0026gt; 40075c:\t17fffffd b\t400750 \u0026lt;phase_0+0x1c\u0026gt; x0存的是我们输入的字符串，w0中存着read_int返回值，通过gdb的打印，我们可以知道答案为2022\nphase_1 1 2 3 4 5 6 7 8 9 10 11 0000000000400760 \u0026lt;phase_1\u0026gt;: 400760:\ta9bf7bfd stp\tx29, x30, [sp, #-16]! 400764:\t910003fd mov\tx29, sp 400768:\t90000501 adrp\tx1, 4a0000 \u0026lt;.got.plt+0x18\u0026gt; 40076c:\tf9402c21 ldr\tx1, [x1, #88] // 获取0x4a0000+88中的字符串 400770:\t94008504 bl\t421b80 \u0026lt;strcmp\u0026gt; // 比较输入与获取的字符串 400774:\t35000060 cbnz\tw0, 400780 \u0026lt;phase_1+0x20\u0026gt; // 不相等就爆炸 400778:\ta8c17bfd ldp\tx29, x30, [sp], #16 40077c:\td65f03c0 ret 400780:\t940000dd bl\t400af4 \u0026lt;explode\u0026gt; 400784:\t17fffffd b\t400778 \u0026lt;phase_1+0x18\u0026gt; x1中存储的是字符串的起始地址，所以在gdb打印的时候需要再次解引用\n答案：The Network as a System and as a System Component.\nphase_2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 0000000000400788 \u0026lt;phase_2\u0026gt;: 400788:\ta9bc7bfd stp\tx29, x30, [sp, #-64]! 40078c:\t910003fd mov\tx29, sp 400790:\ta90153f3 stp\tx19, x20, [sp, #16] 400794:\t910083e1 add\tx1, sp, #0x20 //数字1的地址为sp+0x20 400798:\t940000f9 bl\t400b7c \u0026lt;read_8_numbers\u0026gt; //读八个数字 40079c:\tb94023e0 ldr\tw0, [sp, #32] // 获取数字1 4007a0:\t7100041f cmp\tw0, #0x1 // 比较数字1和1 4007a4:\t54000081 b.ne\t4007b4 \u0026lt;phase_2+0x2c\u0026gt; //数字1不等于1就爆炸 4007a8:\tb94027e0 ldr\tw0, [sp, #36] // 获取数字2 4007ac:\t7100041f cmp\tw0, #0x1 // 比较数字2和1 4007b0:\t54000040 b.eq\t4007b8 \u0026lt;phase_2+0x30\u0026gt; //数字2不等于1就爆炸 4007b4:\t940000d0 bl\t400af4 \u0026lt;explode\u0026gt; 4007b8:\t910083f3 add\tx19, sp, #0x20 // x19为数字1地址 4007bc:\t9100e3f4 add\tx20, sp, #0x38 // x20为数字8地址 4007c0:\t14000004 b\t4007d0 \u0026lt;phase_2+0x48\u0026gt; /* 以下代码的c语言大致为 for(int i = 2; i \u0026lt; 8; i++){ if (num[i] != num[i-1]+num[i-2]+3) explode(); } */\t4007c4:\t91001273 add\tx19, x19, #0x4 4007c8:\teb14027f cmp\tx19, x20 4007cc:\t54000140 b.eq\t4007f4 \u0026lt;phase_2+0x6c\u0026gt; // b.none 4007d0:\tb9400260 ldr\tw0, [x19] 4007d4:\tb9400661 ldr\tw1, [x19, #4] 4007d8:\t0b010000 add\tw0, w0, w1 4007dc:\t11000c00 add\tw0, w0, #0x3 4007e0:\tb9400a61 ldr\tw1, [x19, #8] 4007e4:\t6b00003f cmp\tw1, w0 4007e8:\t54fffee0 b.eq\t4007c4 \u0026lt;phase_2+0x3c\u0026gt; // b.none 4007ec:\t940000c2 bl\t400af4 \u0026lt;explode\u0026gt; 4007f0:\t17fffff5 b\t4007c4 \u0026lt;phase_2+0x3c\u0026gt; 4007f4:\ta94153f3 ldp\tx19, x20, [sp, #16] 4007f8:\ta8c47bfd ldp\tx29, x30, [sp], #64 4007fc:\td65f03c0 ret 根据注释中的讲解，我们很容易就推出答案：1 1 5 9 17 29 49 81\nphase_3 这是一道多解题，这里只展示第一种解\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 0000000000400800 \u0026lt;phase_3\u0026gt;: 400800:\ta9be7bfd stp\tx29, x30, [sp, #-32]! 400804:\t910003fd mov\tx29, sp 400808:\t910063e3 add\tx3, sp, #0x18 // 数字2在sp+24中 40080c:\t910073e2 add\tx2, sp, #0x1c // 数字1在sp+28中 400810:\t90000321 adrp\tx1, 464000 \u0026lt;free_mem+0x40\u0026gt; 400814:\t911f6021 add\tx1, x1, #0x7d8 400818:\t9400195a bl\t406d80 \u0026lt;__isoc99_sscanf\u0026gt; // 读取两个数字 40081c:\t7100081f cmp\tw0, #0x2\t400820:\t54000161 b.ne\t40084c \u0026lt;phase_3+0x4c\u0026gt; // 如果数字个数不等于2就爆炸 400824:\tb9401fe0 ldr\tw0, [sp, #28] 400828:\t71000c1f cmp\tw0, #0x3\t40082c:\t540002c0 b.eq\t400884 \u0026lt;phase_3+0x84\u0026gt; // 数字1为3则跳转到0x400884处 400830:\t7100181f cmp\tw0, #0x6 400834:\t54000100 b.eq\t400854 \u0026lt;phase_3+0x54\u0026gt; // b.none 400838:\t7100081f cmp\tw0, #0x2 40083c:\t54000320 b.eq\t4008a0 \u0026lt;phase_3+0xa0\u0026gt; // b.none 400840:\t940000ad bl\t400af4 \u0026lt;explode\u0026gt; 400844:\ta8c27bfd ldp\tx29, x30, [sp], #32 400848:\td65f03c0 ret 40084c:\t940000aa bl\t400af4 \u0026lt;explode\u0026gt; 400850:\t17fffff5 b\t400824 \u0026lt;phase_3+0x24\u0026gt; 400854:\tb9401be2 ldr\tw2, [sp, #24] 400858:\t528ccce0 mov\tw0, #0x6667 // #26215 40085c:\t72acccc0 movk\tw0, #0x6666, lsl #16 400860:\t9b207c40 smull\tx0, w2, w0 400864:\t9362fc00 asr\tx0, x0, #34 400868:\t4b827c00 sub\tw0, w0, w2, asr #31 40086c:\t0b000801 add\tw1, w0, w0, lsl #2 400870:\t4b010441 sub\tw1, w2, w1, lsl #1 400874:\t0b000020 add\tw0, w1, w0 400878:\t7100181f cmp\tw0, #0x6 40087c:\t54fffe40 b.eq\t400844 \u0026lt;phase_3+0x44\u0026gt; // b.none 400880:\t9400009d bl\t400af4 \u0026lt;explode\u0026gt; 400884:\tb9401be0 ldr\tw0, [sp, #24] //读取数字2 400888:\t4a800c00 eor\tw0, w0, w0, asr #3 40088c:\t12000800 and\tw0, w0, #0x7 // 设数字2为x2，此时w0 = (x2 \u0026gt;\u0026gt; 3) \u0026amp; 7 400890:\tb9401fe1 ldr\tw1, [sp, #28] //读取数字1 400894:\t6b01001f cmp\tw0, w1 400898:\t54fffd60 b.eq\t400844 \u0026lt;phase_3+0x44\u0026gt; // 数字1等于w0则返回 40089c:\t94000096 bl\t400af4 \u0026lt;explode\u0026gt; 4008a0:\tb9401be0 ldr\tw0, [sp, #24] 4008a4:\tb9401fe1 ldr\tw1, [sp, #28] 4008a8:\t12000802 and\tw2, w0, #0x7 4008ac:\t6b01005f cmp\tw2, w1 4008b0:\t54fffca0 b.eq\t400844 \u0026lt;phase_3+0x44\u0026gt; // b.none 4008b4:\td3431400 ubfx\tx0, x0, #3, #3 4008b8:\t6b00003f cmp\tw1, w0 4008bc:\t54fffc40 b.eq\t400844 \u0026lt;phase_3+0x44\u0026gt; // b.none 4008c0:\t9400008d bl\t400af4 \u0026lt;explode\u0026gt; 4008c4:\t17ffffdf b\t400840 \u0026lt;phase_3+0x40\u0026gt; 输入两个数x1,x2，若 x1 为 3，则 x1 == (x2 \u0026raquo; 3) \u0026amp; 7\n答案：3 3 or 3 24 \u0026hellip;（符合上述规则都对）\nphase_4 1 2 3 4 5 400300:\t90000510 adrp\tx16, 4a0000 \u0026lt;.got.plt+0x18\u0026gt; 400304:\tf9401a11 ldr\tx17, [x16, #48]\t// 将0x4a0030所存的函数地址放到x17中 400308:\t9100c210 add\tx16, x16, #0x30 40030c:\td61f0220 br\tx17 // 跳转到该函数执行 // 通过gdb打印的地址，我们可以查询到函数的名字是 strlen 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 00000000004009e4 \u0026lt;phase_4\u0026gt;: 4009e4:\ta9be7bfd stp\tx29, x30, [sp, #-32]! 4009e8:\t910003fd mov\tx29, sp 4009ec:\ta90153f3 stp\tx19, x20, [sp, #16] 4009f0:\taa0003f3 mov\tx19, x0 // 将输入复制一份到x19 4009f4:\t97fffe43 bl\t400300 \u0026lt;.plt+0x60\u0026gt; // 跳转到外部链接（400300代码在上面） 4009f8:\taa0003f4 mov\tx20, x0 // 将输入复制一份到x20 4009fc:\t7100281f cmp\tw0, #0xa 400a00:\t540001ec b.gt\t400a3c \u0026lt;phase_4+0x58\u0026gt; // 如果返回值大于10就爆炸 400a04:\t2a1403e1 mov\tw1, w20 400a08:\taa1303e0 mov\tx0, x19 400a0c:\t97ffffaf bl\t4008c8 \u0026lt;encrypt_method1\u0026gt; // 加密函数1 400a10:\t2a1403e1 mov\tw1, w20 400a14:\taa1303e0 mov\tx0, x19 400a18:\t97ffffd3 bl\t400964 \u0026lt;encrypt_method2\u0026gt; // 加密函数2 400a1c:\t90000500 adrp\tx0, 4a0000 \u0026lt;.got.plt+0x18\u0026gt; 400a20:\tf9403401 ldr\tx1, [x0, #104] // 获取0x4a0000+104处的值，是一个字符串 400a24:\taa1303e0 mov\tx0, x19 400a28:\t94008456 bl\t421b80 \u0026lt;strcmp\u0026gt; // 调用strcmp函数比较 // 如果加密后的字符串与获取的字符串不等就爆炸 400a2c:\t350000c0 cbnz\tw0, 400a44 \u0026lt;phase_4+0x60\u0026gt; 400a30:\ta94153f3 ldp\tx19, x20, [sp, #16] 400a34:\ta8c27bfd ldp\tx29, x30, [sp], #32 400a38:\td65f03c0 ret 400a3c:\t9400002e bl\t400af4 \u0026lt;explode\u0026gt; 400a40:\t17fffff1 b\t400a04 \u0026lt;phase_4+0x20\u0026gt; 400a44:\t9400002c bl\t400af4 \u0026lt;explode\u0026gt; 400a48:\t17fffffa b\t400a30 \u0026lt;phase_4+0x4c\u0026gt; 这道题有点难，但我们可以很快知道需要输入一个长度不大于10的字符串，且我们也可以很快知道最终要比较的字符串为isggstsvkt\n接下来是要知道两个加密函数做了些什么，然而通过看代码，我们其实很难看懂是怎么加密的，但是我们可以通过不断地输入来获取算法结果，最终得到算法的加密方式。\n通过输入0123456789我们可以得到经过加密函数1之后的结果为0246813579，很显然这是将位置做了一下调换。然而这个输入在加密函数2中直接就爆炸了\n结合最终字符串以及输入0123456789的结果，我们可以猜测函数2是一个字母表的加密算法，故而我们尝试输入abcdefghij，得到经过加密函数2的结果为qetuowryip，之后我们可以很容易的得到abcdefghij在加密表中对应qwertyuiop，将26个字母都输入了一遍之后，我们就可以知道应该输入的字符串为helloworle\nphase_5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 0000000000400a4c \u0026lt;func_5\u0026gt;: // 通过分析这个函数，我们可以知道参数2应该为一个二叉树的根地址 400a4c:\tb4000361 cbz\tx1, 400ab8 \u0026lt;func_5+0x6c\u0026gt; // 如果该节点为空就返回0 400a50:\ta9be7bfd stp\tx29, x30, [sp, #-32]! 400a54:\t910003fd mov\tx29, sp 400a58:\ta90153f3 stp\tx19, x20, [sp, #16] 400a5c:\t2a0003f4 mov\tw20, w0 400a60:\taa0103f3 mov\tx19, x1 400a64:\tb9400020 ldr\tw0, [x1] 400a68:\t6b14001f cmp\tw0, w20 400a6c:\t54000160 b.eq\t400a98 \u0026lt;func_5+0x4c\u0026gt; // b.none 400a70:\tb9400260 ldr\tw0, [x19] 400a74:\t6b14001f cmp\tw0, w20 400a78:\t5400014d b.le\t400aa0 \u0026lt;func_5+0x54\u0026gt; 400a7c:\tf9400661 ldr\tx1, [x19, #8] 400a80:\t2a1403e0 mov\tw0, w20 400a84:\t97fffff2 bl\t400a4c \u0026lt;func_5\u0026gt; 400a88:\t531f7800 lsl\tw0, w0, #1 400a8c:\ta94153f3 ldp\tx19, x20, [sp, #16] 400a90:\ta8c27bfd ldp\tx29, x30, [sp], #32 400a94:\td65f03c0 ret 400a98:\t94000017 bl\t400af4 \u0026lt;explode\u0026gt; 400a9c:\t17fffff5 b\t400a70 \u0026lt;func_5+0x24\u0026gt; 400aa0:\tf9400a61 ldr\tx1, [x19, #16] 400aa4:\t2a1403e0 mov\tw0, w20 400aa8:\t97ffffe9 bl\t400a4c \u0026lt;func_5\u0026gt; 400aac:\t531f7800 lsl\tw0, w0, #1 400ab0:\t11000400 add\tw0, w0, #0x1 400ab4:\t17fffff6 b\t400a8c \u0026lt;func_5+0x40\u0026gt; 400ab8:\t52800000 mov\tw0, #0x0 // #0 400abc:\td65f03c0 ret 1 2 3 4 5 6 7 8 9 10 11 12 13 14 0000000000400ac0 \u0026lt;phase_5\u0026gt;: 400ac0:\ta9bf7bfd stp\tx29, x30, [sp, #-16]! 400ac4:\t910003fd mov\tx29, sp 400ac8:\t94000043 bl\t400bd4 \u0026lt;read_int\u0026gt; // 读入一个整数 400acc:\t90000501 adrp\tx1, 4a0000 \u0026lt;.got.plt+0x18\u0026gt; 400ad0:\t91016021 add\tx1, x1, #0x58 400ad4:\t91006021 add\tx1, x1, #0x18 400ad8:\t97ffffdd bl\t400a4c \u0026lt;func_5\u0026gt; // 调用一个函数，参数2为一个地址 400adc:\t71000c1f cmp\tw0, #0x3 400ae0:\t54000061 b.ne\t400aec \u0026lt;phase_5+0x2c\u0026gt; //返回值不等于3就爆炸 400ae4:\ta8c17bfd ldp\tx29, x30, [sp], #16 400ae8:\td65f03c0 ret 400aec:\t94000002 bl\t400af4 \u0026lt;explode\u0026gt; 400af0:\t17fffffd b\t400ae4 \u0026lt;phase_5+0x24\u0026gt; 这道题也很难，但我们可以一力破万法，既然我们已经知道需要遍历一个二叉树，那我们一个个打印，可以知道二叉树的结构如下：\n如果你懒得看func_5的逻辑了，那么你可以跟我一样一个一个试，将所有二叉树插入节点的位置都试一遍，比如：0, 4, 21, 38, 50, 56, 89, 92，当我们试到89时就得到答案了。\n","date":"2024-11-17T16:07:58+08:00","permalink":"http://localhost:1313/blogs/chcore_lab0-%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0/","title":"ChCore_lab0 做题笔记"},{"content":"WSL 连接 Vscode 打开 vscode 点击左下角的蓝色标 选择连接到WSL即可连接到默认的WSL子系统，如果你有多个子系统，可以选择使用发行版连接到WSL，然后选择你想要连接的子系统 进入子系统之后你就可以像在本地一样使用 vscode 来操作子系统啦，你可以使用快捷键 ctrl+`快速调出终端，然后就可以进行一些命令行操作啦\n安装vscode插件 由于使用vscode连接wsl的原理是在wsl里面开启一个vscode server，所以本机的插件是不会与wsl里面的插件共享的，你需要在插件页面安装对应的插件。\n推荐两个好用的 vscode 插件\nFavorites Manager：简单方便地文件夹收藏夹，将你常用文件夹添加到收藏夹，之后就可以通过它快速打开 Open Folder Context Menus for VS Code：可以让你快速地打开文件夹中的子文件夹，配合Favorites Manager可以高效找寻并打开想要的文件夹路径 ​\t由于vscode扩展的服务器是在国外，所以安装插件会出现加载缓慢或者加载不出来的情况，为了良好的体验，建议使用魔法来加速\n​\t不单止vscode，目前jetbrains全家桶也支持连接wsl来进行项目开发，不过笔者不常用jetbrains系的ide，所以没有实际体验过，感兴趣的可以自行去体验一下\n","date":"2024-10-30T23:47:42+08:00","image":"http://localhost:1313/blogs/03-%E5%9C%A8vscode%E4%B8%AD%E4%BD%BF%E7%94%A8wsl%E8%BF%9B%E8%A1%8C%E5%BC%80%E5%8F%91/OIP-C_x16_drawing_hu14351242286450249137.jpg","permalink":"http://localhost:1313/blogs/03-%E5%9C%A8vscode%E4%B8%AD%E4%BD%BF%E7%94%A8wsl%E8%BF%9B%E8%A1%8C%E5%BC%80%E5%8F%91/","title":"03 在VSCode中使用WSL进行开发"},{"content":"安装 WSL Toolbox 使用 Microsoft Store 搜索 \u0026ldquo;WSL Toolbox\u0026rdquo;，点击安装即可。 也可以通过此链接安装：WSL Toolbox\n配置默认启动用户 (仅Ubuntu，其它发行版自行搜索) 不管使用 WSL 命令还是在 WSL Toolbox（以下简称 WT）中进入子系统，默认是使用root模式访问的，接下来我们要将默认访问用户改成安装系统时创建的那个。如果你享受root模式的裸奔快感，这一步可以跳过。\n先检查 wsl.conf 文件是否存在\n1 cat /etc/wsl.conf 如果文件不存在则创建一个\n1 touch /etc/wsl.conf 将以下内容写入该文件\n1 2 3 4 [boot] systemd=true #启用systemd命令，无脑开就行，能够解决一些兼容性问题 [user] default=YourName #这里替换成你的用户名 由于只能在子系统内部更改该文件，所以学会使用vim是必要的： Linux vi/vim | 菜鸟教程 (runoob.com)\n重启子系统即可生效 （推荐使用WT操作）\n更改子系统路径 子系统默认安装在C盘，为了不过分占用C盘空间，修改子系统路径是很必要的\n使用 WT 导出子系统\n点击Export之后保存到你想要存放子系统的路径（甚至可以存放在移动硬盘中）\n使用 WT 导入你的子系统\n选择刚刚导出的子系统文件，只修改系统名称即可\n将原来的子系统 Delete 掉就好了\n导出的子系统文件千万不要删除，以备后续可以通过 import 方便地增加子系统或者重装子系统\n如果你将wsl系统装在了外置存储设备，请不要在存储设备离开时打开WT，否则会导致WT崩溃，需要自行前往修复\n具体操作： 设置 \u0026raquo; 应用 \u0026raquo; 安装的应用 \u0026raquo; 找到WT选择高级选项 \u0026raquo; 修复 or 重置\n参考链接 WSL入门到入土 - 知乎 (zhihu.com) WSL Toolbox Linux vi/vim | 菜鸟教程 (runoob.com) ","date":"2024-10-02T23:45:47+08:00","image":"http://localhost:1313/blogs/02-%E4%BD%BF%E7%94%A8wsl-toolbox%E7%AE%A1%E7%90%86%E4%BD%A0%E7%9A%84linux%E5%AD%90%E7%B3%BB%E7%BB%9F/OIP-C_x16_drawing_hu14351242286450249137.jpg","permalink":"http://localhost:1313/blogs/02-%E4%BD%BF%E7%94%A8wsl-toolbox%E7%AE%A1%E7%90%86%E4%BD%A0%E7%9A%84linux%E5%AD%90%E7%B3%BB%E7%BB%9F/","title":"02 使用WSL ToolBox管理你的Linux子系统"},{"content":" ​\t随着我们学习的编程语言越来越多，使用的各种各样的工具也越来越多，我们的电脑上就需要配置越来越多的环境，且不论环境之间是否具有冲突，单从复杂的系统环境来看，都会让电脑变的臃肿，最终就会出现牵一发而动全身的情况（All in boom）。\n​\t然而，目前win平台对于此并没有过多的方案选择，基本只有docker、Windows沙盒、传统VM以及 WSL 三个选项来管理你的系统环境，让系统变得更加清爽。\n​\tWindows沙盒只能在专业版中使用，鉴于大部分人都没有专业版，故并不推荐； 传统VM由于运行在应用层，在进行资源调度以及数据共享时极不方便，故不推荐；docker，由于docker并没有win的原生版本，即使是windows版本也是基于wsl的，于是乎你就在装了一个wsl的前提下，又安装了个docker，在神级插件Dev-Container辅助下，确实很不错，由于笔者没有尝试过，所以不做评价。\n​\tWSL也是一种虚拟机，由于win的原生支持，其不仅能够与win进行极其方便的数据共享，还能够方便的与宇宙第一IDE VScode 进行一触即连，优雅方便地开始你的代码开发，最重要的是，其能够完美地调用所有的计算资源而不需要手动调整，实在是管理系统环境的不二之选。\n​\t2024.11.12 笔者的笔记本坏了，需要重装系统，尽管重要数据能够通过硬盘、网盘来备份，但是一些系统环境要重新配置还是很费时间的。由于笔者已经投入了wsl怀抱，这时候只需要将所有的子系统导出，然后重要数据都放在同步盘里，就能够非常方便地重装系统然后恢复原来的环境了。\n启用基于Linux的子系统功能 在 Win10 or Win11 中，使用任务栏的搜索功能，搜索“启用或关闭windows功能”\n单击进入下图窗口，启用 “适用于Linux的Windows子系统功能” 和 \u0026ldquo;虚拟机平台\u0026rdquo;\n安装 WSL 子系统 使用 cmd，输入以下命令更新 WSL\n1 WSL --update 启用 WSL2 —— 目前默认使用 WSL2，但建议手动启用一下更为保险，WSL2 的功能比 1 更完善也更加稳定\n1 WSL --set-default-version 2 查看可用的WSL系统版本，并安装ubuntu系统 —— 这里安装的是22.04版本，没特殊需求使用22.04版本就够了\n1 2 WSL -l -o WSL --install Ubuntu-22.04 --web-download 这里请务必加上 --web-download ，否则他会从MS Store下载，亲测奇慢无比\n接下来只需跟着引导创建用户然后，设置密码即可，之后你可以在CMD或者Power Shell输入WSL来进入子系统\n意外情况 不出意外的话，这时候可能就出意外了\n意外一\n1 WSL -l -o 如果没有反应，这一般是那堵无形的墙堵住了你的去路。\n解决方法: 尝试换一个网绕过去，或者装个梯子爬过去\nps：经笔者尝试，目前国内是可以直接访问安装的，如果不行，配置一下DNS就好了\n​\t推荐：首选119.29.29.29 备用8.8.8.8\n意外二\n1 WSL --install Ubuntu-22.04 --web-download 安装系统失败，首先尝试根据官方文档中的操作一步一步来：旧版 WSL 的手动安装步骤 | Microsoft Learn\n如果仍然安装系统失败，你可以尝试使用windows更新修复问题，然后重试上述步骤。\n还有可能是因为bios未启用cpu虚拟化。 —— 然而 笔者在使用VM时显示不支持cpu虚拟化，但却能够使用WSL\n此时依然不行的话，要么就是系统不支持，要么就是硬件不支持，可以尝试重装系统或者更换电脑解决\n参考链接： WSL入门到入土 - 知乎 (zhihu.com) 旧版 WSL 的手动安装步骤 | Microsoft Learn ","date":"2024-10-01T23:46:05+08:00","image":"http://localhost:1313/blogs/01-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8wsl%E5%AE%89%E8%A3%85linux%E7%B3%BB%E7%BB%9F/OIP-C_x16_drawing_hu14351242286450249137.jpg","permalink":"http://localhost:1313/blogs/01-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8wsl%E5%AE%89%E8%A3%85linux%E7%B3%BB%E7%BB%9F/","title":"01 如何使用WSL安装Linux系统"}]